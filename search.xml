<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>qexo</title>
    <url>/posts/f69/</url>
    <content><![CDATA[<p><strong>qexo</strong></p>
]]></content>
      <categories>
        <category>hexo</category>
        <category>quxo</category>
      </categories>
      <tags>
        <tag>qexo</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>ansible</title>
    <url>/posts/ea2c/</url>
    <content><![CDATA[<p>ansible  常用操作</p>
<span id="more"></span>

<h2 id="cron"><a href="#cron" class="headerlink" title="cron"></a>cron</h2><p><strong>Ansible cron</strong>模块主要用于添加、删除、更新操作系统的crontab任务计划</p>
<p>cron模块使用详解：</p>
<pre class="line-numbers language-none"><code class="language-none">name：任务计划名称
cron_file：替换客户端该用户的任务计划的文件
minute：分（0-59， * ，*&#x2F;2）
hour：时（0-23， * ，*&#x2F;2）
day：日（1-31， * ，*&#x2F;2）
month：月（1-12， * ， *&#x2F;2）
weekday：周（0-6或1-7， *）
job：任何计划执行的命令，state要等于present
backup：是否备份之前的任务计划
user：新建任务计划的用户
state：指定任务计划present、absent<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id><a href="#" class="headerlink" title></a></h2><h3 id="创建计划任务"><a href="#创建计划任务" class="headerlink" title="创建计划任务"></a>创建计划任务</h3><p>在 ansible-demo3 主机上创建计划任务，任务名称为”crontab test”，任务于每天1点5分执行，任务内容为输出test字符。</p>
<pre class="line-numbers language-none"><code class="language-none">ansible ansible-demo3 -m cron -a &quot; name&#x3D;&#39;crontab test&#39; minute&#x3D;5 hour&#x3D;1 job&#x3D;&#39;echo test&#39; &quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h3 id="修改定时任务"><a href="#修改定时任务" class="headerlink" title="修改定时任务"></a>修改定时任务</h3><p>操作同名的任务时，ansible 将会认为是修改原来的任务,启用了 backup，所以任务在修改前会被备份</p>
<pre class="line-numbers language-none"><code class="language-none">ansible ansible-demo3 -m cron -a &quot; name&#x3D;&#39;crontab test&#39;  minute&#x3D;5 hour&#x3D;2 job&#x3D;&#39;echo test1&#39; backup&#x3D;yes&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h3 id="删除计划任务"><a href="#删除计划任务" class="headerlink" title="删除计划任务"></a>删除计划任务</h3><pre class="line-numbers language-none"><code class="language-none">ansible ansible-demo3 -m cron -a &quot; name&#x3D;&#39;crontab test&#39; state&#x3D;absent backup&#x3D;yes &quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h3 id="任务注释掉"><a href="#任务注释掉" class="headerlink" title="任务注释掉"></a>任务注释掉</h3><pre class="line-numbers language-none"><code class="language-none">ansible ansible-demo3 -m cron -a &quot; name&#x3D;&#39;crontab test&#39;  job&#x3D;&#39;echo test1&#39; disabled&#x3D;yes  backup&#x3D;yes&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h2 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h2><pre class="line-numbers language-none"><code class="language-none">ansible test -m copy -a &quot;src&#x3D;test.sh dest&#x3D;&#x2F;root dest&#x3D;&#x2F;tmp backup&#x3D;yes  owner&#x3D;liuhao group&#x3D;liuhao mode&#x3D;0644&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h2 id="file"><a href="#file" class="headerlink" title="file"></a>file</h2><pre class="line-numbers language-none"><code class="language-none">ansible ansible-demo3 -m file -a &quot;path&#x3D;&#x2F;testdir&#x2F;testfile1 state&#x3D;touch owner&#x3D;liuhao group&#x3D;liuhao&quot;

ansible ansible-demo3 -m file -a &quot;path&#x3D;&#x2F;testdir&#x2F;testdir state&#x3D;directory owner&#x3D;liuhao group&#x3D;liuhao&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<p>删除远程机器上的指定文件或目录。</p>
<pre class="line-numbers language-none"><code class="language-none">ansible ansible-demo3 -m file -a &quot;path&#x3D;&#x2F;testdir&#x2F;testdir state&#x3D;absent&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>





<h2 id="fetch"><a href="#fetch" class="headerlink" title="fetch"></a>fetch</h2><p>复制远程文件到本地</p>
<pre class="line-numbers language-none"><code class="language-none">ansible all -m fetch -a &quot;src&#x3D;&#x2F;tmp&#x2F;log&#x2F;* dest&#x3D;&#x2F;tmp&#x2F;&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><p>重启应用</p>
<pre class="line-numbers language-none"><code class="language-none">ansible 10.1.1.113 -m service -a &#39;name&#x3D;puppet state&#x3D;restarted enabled&#x3D;yes&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h2 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h2><p>安装tree</p>
<pre class="line-numbers language-none"><code class="language-none">ansible all -m yum -a &quot;state&#x3D;present name&#x3D;tree&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<p>安装本地rpm包</p>
<pre class="line-numbers language-none"><code class="language-none">ansible all -m yum  -a &#39;name&#x3D;&#x2F;root&#x2F;jdk-7u71-linux-x64.rpm state&#x3D;installed&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<p>执行本地shell脚本</p>
<p>ansible all -m script -a ‘.&#x2F;test.sh’</p>
]]></content>
      <categories>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>gitlab权限</title>
    <url>/posts/9ef6/</url>
    <content><![CDATA[<h1 id="Gitlab权限概念"><a href="#Gitlab权限概念" class="headerlink" title="Gitlab权限概念"></a>Gitlab权限概念</h1><p>用户具有不同的能力，具体取决于他们在特定组或项目中的访问级别。如果用户同时在组的项目和项目本身中，则使用最高权限级别。</p>
<p>在公共和内部项目中，不会强制实施Guest角色。所有用户都可以创建问题，发表评论，克隆或下载项目代码。</p>
<p>当成员离开团队时， 将自动取消分配所有分配的问题和合并请求。</p>
<p>GitLab 管理员获得所有权限。</p>
<h1 id="Gitlab权限列表"><a href="#Gitlab权限列表" class="headerlink" title="Gitlab权限列表"></a>Gitlab权限列表</h1><p>这里要列一下权限分类，因为gitlab的成员权限不单单只有一种。</p>
<ul>
<li><p>项目成员角色</p>
</li>
<li><ul>
<li>Guest - 客人</li>
<li>Reporter - 记者</li>
<li>Developer - 开发者</li>
<li>Master (11.0版本中已重命名为 Maintainer) - 维护者</li>
<li>Owner - 所有者</li>
</ul>
</li>
<li><p>组成员角色</p>
</li>
<li><ul>
<li>Guest - 客人</li>
<li>Reporter - 记者</li>
<li>Developer - 开发者</li>
<li>Master (11.0版本中已重命名为 Maintainer) - 维护者</li>
<li>Owner - 维护者</li>
</ul>
</li>
<li><p>GitLab CI-CD 角色</p>
</li>
<li><ul>
<li>Guest, Reporter - 客人，记者</li>
<li>Developer - 开发者</li>
<li>Maintainer - 维护者</li>
<li>Admin - 管理员</li>
</ul>
</li>
<li><p>工作角色</p>
</li>
<li><ul>
<li>Guest, Reporter - 客人，记者</li>
<li>Developer - 开发者</li>
<li>Maintainer - 维护者</li>
<li>Admin - 管理员</li>
</ul>
</li>
</ul>
<p>一般管理员邀请用户加入到项目里都需要分配权限，如下：</p>
<h1 id="项目成员权限"><a href="#项目成员权限" class="headerlink" title="项目成员权限"></a>项目成员权限</h1><p>注意：在GitLab 11.0中，Master已重命名为Maintainer。</p>
<table>
<thead>
<tr>
<th>Action</th>
<th>Guest</th>
<th>Reporter</th>
<th>Developer</th>
<th>Maintainer</th>
<th>Owner</th>
</tr>
</thead>
<tbody><tr>
<td>创建新问题</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>创建机密问题</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>查看机密问题</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>留言</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>查看相关问题</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>查看工作列表</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>查看工作日志</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>下载并浏览作业工件</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>查看维基页面</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>查看许可证管理报告</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>查看安全报告</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>查看项目代码</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>拉项目代码</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>下载项目</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>分配问题</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>分配合并请求</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>标签问题</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>标签合并请求</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>创建代码段</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>管理问题跟踪器</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>管理标签</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>查看提交状态</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>查看容器注册表</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>查看环境</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>查看合并请求列表</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>管理相关问题</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>锁定问题讨论</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>从漏洞创建问题</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>查看错误跟踪列表</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>锁定合并请求讨论</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>创建新环境</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>停止环境</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>管理&#x2F;接受合并请求</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>创建新的合并请求</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>创建新分支</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>推送到未受保护的分支机构</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>强制推送到不受保护的分支机构</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>删除未受保护的分支</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>添加标签</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>写一个维基</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>取消并重试作业</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>创建或更新提交状态</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>更新容器注册表</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>删除容器注册表图像</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>创建&#x2F;编辑&#x2F;删除项目里程碑</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>查看已批准&#x2F;列入黑名单的许可</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>使用安全仪表板</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>解除漏洞</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>应用代码更改建议</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="组成员权限"><a href="#组成员权限" class="headerlink" title="组成员权限"></a>组成员权限</h1><table>
<thead>
<tr>
<th>Action</th>
<th>Guest</th>
<th>Reporter</th>
<th>Developer</th>
<th>Maintainer</th>
<th>Owner</th>
</tr>
</thead>
<tbody><tr>
<td>浏览组</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>编辑组</td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>创建子组</td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>在组中创建项目</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>管理小组成员</td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>删除组</td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>管理组标签</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>创建&#x2F;编辑&#x2F;删除组里程碑</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
<td></td>
</tr>
<tr>
<td>查看组史诗</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>创建&#x2F;编辑组史诗</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td></td>
</tr>
<tr>
<td>删除组史诗</td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>查看组审核事件</td>
<td>✓</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h1 id="GitLab-CI-CD权限"><a href="#GitLab-CI-CD权限" class="headerlink" title="GitLab CI &#x2F; CD权限"></a>GitLab CI &#x2F; CD权限</h1><table>
<thead>
<tr>
<th>Action</th>
<th>Guest, Reporter</th>
<th>Developer</th>
<th>Maintainer</th>
<th>Admin</th>
</tr>
</thead>
<tbody><tr>
<td>查看提交和工作</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>重试或取消工作</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>擦除作业工件和跟踪</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>删除项目</td>
<td></td>
<td></td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>创建项目</td>
<td></td>
<td></td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>更改项目配置</td>
<td></td>
<td></td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>添加特定的跑步者</td>
<td></td>
<td></td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>添加共享的运行者</td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td>查看系统中的事件</td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
<tr>
<td>管理界面</td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
</tbody></table>
<h1 id="工作权限"><a href="#工作权限" class="headerlink" title="工作权限"></a>工作权限</h1><table>
<thead>
<tr>
<th>Action</th>
<th>Guest, Reporter</th>
<th>Developer</th>
<th>Maintainer</th>
<th>Admin</th>
</tr>
</thead>
<tbody><tr>
<td>运行CI作业</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>从当前项目克隆源和LFS</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>从公共项目克隆源和LFS</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>从内部项目克隆源和LFS</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>私有项目的克隆源和LFS</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>推送源和LFS</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>从当前项目中提取容器图像</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>从公共项目中提取容器图像</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>从内部项目中提取容器图像</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>从私人项目中提取容器图像</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>将容器图像推送到当前项目</td>
<td></td>
<td>✓</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>将容器图像推送到其他项目</td>
<td></td>
<td></td>
<td></td>
<td>✓</td>
</tr>
</tbody></table>
<p>参考资料</p>
<p><a href="https://docs.gitlab.com/ee/user/permissions.html">https://docs.gitlab.com/ee/user/permissions.html</a></p>
]]></content>
      <categories>
        <category>git</category>
        <category>gitlab</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>gitlab-hook服务端规范提交邮箱</title>
    <url>/posts/8938/</url>
    <content><![CDATA[<h1 id="服务端钩子"><a href="#服务端钩子" class="headerlink" title="服务端钩子"></a>服务端钩子</h1><p><a href="https://github.com/geeeeeeeeek/git-recipes/wiki/5.4-Git-%E9%92%A9%E5%AD%90%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81">https://github.com/geeeeeeeeek/git-recipes/wiki/5.4-Git-%E9%92%A9%E5%AD%90%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BD%A0%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81</a></p>
<p><a href="https://www.git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90">https://www.git-scm.com/book/zh/v2/%E8%87%AA%E5%AE%9A%E4%B9%89-Git-Git-%E9%92%A9%E5%AD%90</a><br>hook可以分为客户端和服务端</p>
<p>这些钩子都允许你对 git push 的不同阶段做出响应。</p>
<ul>
<li>pre-receive</li>
<li>update</li>
<li>post-receive</li>
</ul>
<p>修改custom_hooks_dir路径<br>vi &#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb</p>
<pre class="line-numbers language-none"><code class="language-none">gitlab_shell[&#39;custom_hooks_dir&#39;] &#x3D; &#x2F;opt&#x2F;gitlab&#x2F;embedded&#x2F;service&#x2F;gitlab-shell&#x2F;custom_hooks
sudo gitlab-ctl reconfigure 
gitlab-ctl restart&#x2F;&#x2F;重启gitlab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>





<pre class="line-numbers language-none"><code class="language-none">#!&#x2F;bin&#x2F;sh
read  new ref
log&#x3D;$(git log -1 $ref )
em&#x3D;$&#123;log#*&lt;&#125;
email&#x3D;$&#123;em%&gt;*&#125;
temp&#x3D;$&#123;log#*@&#125;
email_suffix&#x3D;$&#123;temp%&gt;*&#125;
if [ $&#123;email_suffix&#125; !&#x3D; &#39;qq.com&#39; ];then
echo &#39;you commit code use email is: &quot;&#39;$email &#39;&quot; the suffix of this email  is :&#39;$&#123;email_suffix&#125;&#39;
Email format error: &quot;&#39;$email&#39;&quot; is not  formal qq OA email
can not commit your code , unless follow these steps to modify your email to OA email
steps:1. git config --global  --replace-all user.email xxx@qq.com
      2.  git commit --amend --author &quot;xxx &lt;xxx@qq.com&gt;&quot; 
         (modify author email to OA email(xxx@qq.com) in your commit infos )
      3. :wq
 
attention: if your commit code use email is different from your OA email (xxx@qq.com) ,your code will not statistical&#39;
exit 1
        else
echo &#39;your email is OA email&#39;
exit 0
fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>git</category>
        <category>gitlab</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客中如何插入图片</title>
    <url>/posts/7468/</url>
    <content><![CDATA[<p>众所周知，在md文件中插入图片的语法为<code>![]()</code>。<br>其中<strong>方括号</strong>是图片描述，<strong>圆括号</strong>是图片路径。<br>一般来说有三种图片路径，分别是<strong>相对路径，绝对路径和网络路径</strong>。<br>所谓的网络路径就是直接引用网上的图片，直接复制图片地址，放在圆括号中就完事了。<br>这种方式十分的方便，但是也存在一定的问题：</p>
<span id="more"></span>

<ul>
<li>图片失效导致无法加载；</li>
<li>打开网页后要再请求加载图片；</li>
<li>原网站限制，如微信公众号的图片会变得不可见等。<br>这种方式算是有利有弊。<br>绝对路径是图片在计算机中的绝对位置，相对路径是相对于当前文件的路径。<br>由于我们的博客是要部署在网站上，部署后会生成新的文件目录，所以我们选择使用相对路径的方式。<br>在hexo中使用<strong>文章资源文件夹</strong>需要在<code>config.yaml</code>文件中更改一下配置：</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">post_asset_folder: true
marked:
  prependRoot: true
  postAsset: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>





<h2 id="hexo与Typora的完美结合"><a href="#hexo与Typora的完美结合" class="headerlink" title="hexo与Typora的完美结合"></a>hexo与Typora的完美结合</h2><img data-src="/posts/7468/image-20230810112545725.png" class>

<p>使用该配置后，可以直接复制网页中的图片地址，粘贴到Typora中后，会直接复制该图片到文章资源文件夹，同时自动更改路径。</p>
<p>如复制网络路径的图片<code>https://...../image.jpg</code>粘贴到Typora中叫<code>文章名</code>的文章后，图片会自动变为<code>![](文章名/image.jpg)</code>。</p>
]]></content>
  </entry>
  <entry>
    <title>Bash 脚本中的 set -euxo pipefail</title>
    <url>/posts/fen3/</url>
    <content><![CDATA[<p>在Ruby或者Python等高级语言里，你很容易知道错误是哪行什么类型的错误，还有IDE的Debugger加持。而Bash只能看源码，通过打印log等非常低效的方式调试。</p>
<p>本文将介绍Bash中 <code>set -euxo pipefail</code>，它们可以帮助你写出更容易维护也更安全的脚本</p>
<span id="more"></span>



<h2 id="set-e"><a href="#set-e" class="headerlink" title="set -e"></a>set -e</h2><p><code>set -e</code> 选项可以让你的脚本在出现异常时马上退出，后续命令不再执行。默认情况下Shell脚本不会因为错误而结束执行，但大多数情况是，我们希望出现异常时就不要再往下走了。假如你的<code>if</code>判断条件里会出现异常，这时脚本也会直接退出.<br>如果不想立即退出，可以使用 <code>|| true</code> 来阻止退出。</p>
<h2 id="set-o-pipefail"><a href="#set-o-pipefail" class="headerlink" title="set -o pipefail"></a>set -o pipefail</h2><p>默认情况下Bash只会检查管道（pipeline）操作最后一个命令的返回值，假如最右边的命令成功那么它就认为这个语句没问题。这个行为其实是很不安全的，所以就有了<code>set -o pipefail</code>。这个特别的选项表示在管道连接的命令中，只要有任何一个命令失败（返回值非0），则整个管道操作被视为失败。只有管道中所有命令都成功执行了这个管道才算成功执行。</p>
<h2 id="set-u"><a href="#set-u" class="headerlink" title="set -u"></a>set -u</h2><p><code>set -u</code> 比较容易理解，Bash会把所有未定义的变量视为错误。默认情况下Bash会将未定义的变量视为空，不会报错</p>
<p>除了 <code>$*</code> 和 <code>$@</code>，对您之前未定义的任何变量的引用都是一个错误，并导致程序立即退出。</p>
<h2 id="set-x"><a href="#set-x" class="headerlink" title="set -x"></a>set -x</h2><p><code>set -x</code> 可以让Bash把每个命令在执行前先打印出来，你可以认为这就是Bash的Debug开关。它的好处当然显而易见，方便你快速找到有问题的脚本位置，但是也坏处也有吧，就是Bash的log会格外的乱。另外，它在打印命令前会把变量先解析出来，所以你可以知道当前执行的语句的变量值是什么。纵然log可能会乱一些，总比头发乱一些好，所以建议还是打开这个开关。</p>
<h2 id="Setting-IFS"><a href="#Setting-IFS" class="headerlink" title="Setting IFS"></a>Setting <code>IFS</code></h2><p>IFS 变量，代表内部字段分隔符</p>
<pre class="line-numbers language-none"><code class="language-none">#!&#x2F;bin&#x2F;bash
IFS&#x3D;$&#39; &#39;
items&#x3D;&quot;a b c&quot;
for x in $items; do
    echo &quot;$x&quot;
done

IFS&#x3D;$&#39;\n&#39;
for y in $items; do
    echo &quot;$y&quot;
done
... will print out this:

a
b
c
a b c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>对于第一个循环，IFS 是一个空格，这意味着单词由空格字符分隔。</p>
<p>对于第二个循环，“单词”由换行符分隔，这意味着 bash 将“项目”的整个值视为一个单词。如果 IFS 有多个字符，则将对这些字符中的任何一个进行拆分。</p>
<p>为什么我们要将 IFS 设置为由制表符和换行符组成的字符串？因为它在迭代循环时为我们提供了更好的行为。不太可能导致令人惊讶和令人困惑的错误。</p>
]]></content>
      <categories>
        <category>linux</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>vimdiff 实用指南：高效文件对比与同步操作</title>
    <url>/posts/8ad9/</url>
    <content><![CDATA[<p>vimdiff 是 Linux 开发者必备的轻量级文件对比工具，结合 Vim 的编辑能力和直观的差异标记，适合终端环境下的快速文件对比。本文聚焦核心用法，通过场景化案例讲解高效操作流程。</p>
<h1 id="使用-vimdiff"><a href="#使用-vimdiff" class="headerlink" title="使用 vimdiff"></a>使用 vimdiff</h1><p><strong>比较两个文件差异:</strong></p>
<pre class="line-numbers language-none"><code class="language-none">vimdiff file1 file2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>比较多个文件：</strong><br>你可以同时比较多个文件，vimdiff 会以分屏的形式打开这些文件，每个文件占据一个单独的窗口区域来展示其内容。</p>
<pre class="line-numbers language-none"><code class="language-none">vimdiff file1 file2 file3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p><strong>界面布局</strong></p>
<p>vimdiff 的界面会将两个或多个文件的内容分别显示在垂直或水平分割的窗口中。相同行的文本会被折叠起来，而只有在一个文件中存在的行会被标记为蓝色，另一个文件中存在的行会被标记为绿色。如果两个文件都存在但内容不同的行，会被标记为粉红色，并且差异部分会用红色高亮显示。</p>
<h1 id="快捷键操作"><a href="#快捷键操作" class="headerlink" title="快捷键操作"></a>快捷键操作</h1><h2 id="差异点跳转"><a href="#差异点跳转" class="headerlink" title="差异点跳转"></a>差异点跳转</h2><ul>
<li><p>跳转到下一个差异点：]c</p>
</li>
<li><p>跳转到上一个差异点：[c</p>
</li>
<li><p>跳转到更远的差异点：n]c（n为数字，表示跳过n个差异点）</p>
</li>
</ul>
<h2 id="文件合并"><a href="#文件合并" class="headerlink" title="文件合并"></a>文件合并</h2><p>  将当前文件内容合并到另一边：dp（diff “put”）<br>  将另一边内容合并到当前行：do（diff “obtain”）</p>
<h2 id="窗口移动与焦点切换"><a href="#窗口移动与焦点切换" class="headerlink" title="窗口移动与焦点切换"></a>窗口移动与焦点切换</h2><ul>
<li>在窗口之间切换：<ul>
<li><p>Ctrl-w h：跳转到左边的窗口</p>
</li>
<li><p>Ctrl-w j：跳转到下面的窗口</p>
</li>
<li><p>Ctrl-w k：跳转到上面的窗口</p>
</li>
<li><p>Ctrl-w l：跳转到右边的窗口</p>
</li>
<li><p>Ctrl-w w：跳转到另一个窗口</p>
</li>
<li><p>Ctrl-w Ctrl-w：同 Ctrl-w w</p>
</li>
</ul>
</li>
<li>移动窗口位置：<ul>
<li>Ctrl-w K：把当前窗口移到最上边</li>
<li>Ctrl-w H：把当前窗口移到最左边</li>
<li>Ctrl-w J：把当前窗口移到最下边</li>
<li>Ctrl-w L：把当前窗口移到最右边</li>
</ul>
</li>
</ul>
<h2 id="其他常用操作"><a href="#其他常用操作" class="headerlink" title="其他常用操作"></a>其他常用操作</h2><ul>
<li><p>手动刷新比较结果：:diffupdate</p>
</li>
<li><p>展开折叠区：zo</p>
</li>
<li><p>关闭折叠区：zc</p>
</li>
<li><p>设置上下文行数：:set diffopt&#x3D;context:X（X为你想要的上下文行数）</p>
</li>
<li><p>保存所有文件并退出：:wqa</p>
</li>
<li><p>强制退出所有窗口，不保存更改：:qa!</p>
<h2 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h2><ul>
<li><p>区分大小写：</p>
<ul>
<li><p>set ignorecase：不区分大小写</p>
</li>
<li><p>set noignorecase：区分大小写</p>
</li>
<li><p>粘贴格式不乱：:set paste，按原来的格式粘贴过来</p>
</li>
<li><p>关闭语法高亮：:syntax off，有时能让差异更容易看出来</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  vimdiff 是一款功能强大的文件比较工具，通过其直观的界面和丰富的快捷键操作，可以大大提高文件对比与同步的效率。无论是日常开发中的代码对比，还是文档编辑中的差异查找，vimdiff 都能为你提供极大的便利。希望本文的介绍能帮助你更好地掌握 vimdiff 的使用技巧，提升你的工作效率。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs构建</title>
    <url>/posts/nodejs/</url>
    <content><![CDATA[<p>nodejs 构建常见报错</p>
<span id="more"></span>

<h2 id="node-sass"><a href="#node-sass" class="headerlink" title="node-sass"></a>node-sass</h2><pre class="line-numbers language-none"><code class="language-none">error xxx&#x2F;xxx&#x2F;node_modules&#x2F;node-sass: Command failed.
......
gyp http 404 http:&#x2F;&#x2F;mirrors.tencentyun.com&#x2F;npm&#x2F;node&#x2F;v12.9.1&#x2F;node-v12.9.1-headers.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>配置.npmrc</p>
<pre class="line-numbers language-none"><code class="language-none">registry&#x3D;http:&#x2F;&#x2F;registry.npmmirror.com
sass_binary_site&#x3D;http:&#x2F;&#x2F;npmmirror.com&#x2F;mirrors&#x2F;node-sass
strict-ssl&#x3D;false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx log format</title>
    <url>/posts/fds2/</url>
    <content><![CDATA[<p>nginx 日志详解</p>
<span id="more"></span>

<p>Nginx日志格式和目录通常在配置文件&#x2F;etc&#x2F;nginx&#x2F;nginx.conf中。</p>
<h2 id="Nginx日志格式"><a href="#Nginx日志格式" class="headerlink" title="Nginx日志格式"></a>Nginx日志格式</h2><h3 id="access日志"><a href="#access日志" class="headerlink" title="access日志"></a>access日志</h3><p>配置文件中定义了Nginx日志的打印格式，即main格式：</p>
<pre class="line-numbers language-none"><code class="language-none">log_format main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
                 &#39;$request_time $request_length &#39;
                 &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;
                 &#39;&quot;$http_user_agent&quot;&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>默认格式如下</p>
<pre class="line-numbers language-none"><code class="language-none">log_format main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;
                 &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39; 
                 &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<p>json格式日志</p>
<pre class="line-numbers language-none"><code class="language-none">log_format json_format  &#39;&#123;&quot;@timestamp&quot;:&quot;$time_iso8601&quot;,&#39;
    &#39;&quot;client_ip&quot;:&quot;$remote_addr&quot;,&#39;
    &#39;&quot;remote_user&quot;:&quot;$remote_user&quot;,&#39;
    &#39;&quot;request_method&quot;:&quot;$request_method&quot;,&#39;
    &#39;&quot;protocol&quot;:&quot;$scheme&quot;,&#39;
    &#39;&quot;uri&quot;:&quot;$uri&quot;,&#39;
    &#39;&quot;status&quot;:&quot;$status&quot;,&#39;
    &#39;&quot;upstream_status&quot;:&quot;$upstream_status&quot;,&#39;
    &#39;&quot;size&quot;:&quot;$body_bytes_sent&quot;,&#39;
    &#39;&quot;upstream_response_time&quot;:&quot;$upstream_response_time&quot;,&#39;
    &#39;&quot;upstream_addr&quot;:&quot;$upstream_addr&quot;,&#39;
    &#39;&quot;nginx_node&quot;:&quot;$hostname&quot;,&#39;
    &#39;&quot;http_user_agent&quot;:&quot;$http_user_agent&quot;,&#39;
    &#39;&quot;connection&quot;:&quot;$connection&quot;,&#39;
    &#39;&quot;request_time&quot;:&quot;$request_time&quot;&#125;&#39;; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>声明使用了main这种日志格式和写入的文件名。</p>
<pre class="line-numbers language-none"><code class="language-none">access_log &#x2F;var&#x2F;logs&#x2F;nginx&#x2F;access.log main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>声明使用了json这种日志格式和写入的文件名。</p>
<pre class="line-numbers language-none"><code class="language-none">access_log &#x2F;path&#x2F;to&#x2F;access.log json;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><p>错误日志主要记录客户端访问Nginx出错时的日志，格式不支持自定义。</p>
<p>通过错误日志，你可以得到系统某个服务或server的性能瓶颈等。因此，将日志好好利用，你可以得到很多有价值的信息。错误日志由指令error_log来指定，具体格式如下：</p>
<pre class="line-numbers language-none"><code class="language-none">error_log path(存放路径) level(日志等级)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>path含义同access_log，level表示日志等级，具体如下：<br>[ debug | info | notice | warn | error | crit ]<br>从左至右，日志详细程度逐级递减，即debug最详细，crit最少。</p>
<p>举例说明如下：<br>error_log logs&#x2F;error.log info;<br>需要注意的是：error_log off并不能关闭错误日志，而是会将错误日志记录到一个文件名为off的文件中。</p>
<p>正确的关闭错误日志记录功能的方法如下：<br>error_log &#x2F;dev&#x2F;null;<br>上面表示将存储日志的路径设置为“&#x2F;dev&#x2F;null”。</p>
<h2 id="日志样例"><a href="#日志样例" class="headerlink" title="日志样例"></a>日志样例</h2><p>Nginx日志样例如下：</p>
<pre class="line-numbers language-none"><code class="language-none">192.168.1.2 - - [10&#x2F;Jul&#x2F;2023:15:51:09 +0800] &quot;GET &#x2F;ubuntu.iso HTTP&#x2F;1.0&quot; 0.000 129 404 168 &quot;-&quot; &quot;Wget&#x2F;1.11.4 Red Hat modified&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<p>默认日志</p>
<pre class="line-numbers language-none"><code class="language-none">172.20.0.139 - - [27&#x2F;Aug&#x2F;2023:03:00:24 +0000] &quot;POST &#x2F;api&#x2F;goodsReturn&#x2F;pushUpdateGoods HTTP&#x2F;1.1&quot; 200 17 &quot;-&quot; &quot;okhttp&#x2F;3.11.0&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<h2 id="字段说明"><a href="#字段说明" class="headerlink" title="字段说明"></a>字段说明</h2><table>
<thead>
<tr>
<th>字段名称</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>remote_addr</td>
<td>表示客户端IP地址。</td>
</tr>
<tr>
<td>remote_user</td>
<td>表示客户端用户名称。</td>
</tr>
<tr>
<td>request</td>
<td>表示请求的URL和HTTP协议。</td>
</tr>
<tr>
<td>status</td>
<td>表示请求状态。</td>
</tr>
<tr>
<td>body_bytes_sent</td>
<td>表示发送给客户端的字节数，不包括响应头的大小；该变量与Apache模块modlogconfig里的bytes_sent发送给客户端的总字节数相同。</td>
</tr>
<tr>
<td>bytes_sent</td>
<td>发送给客户端的总字节数</td>
</tr>
<tr>
<td>connection</td>
<td>表示连接的序列号。</td>
</tr>
<tr>
<td>connection_requests</td>
<td>表示当前通过一个连接获得的请求数量。</td>
</tr>
<tr>
<td>msec</td>
<td>表示日志写入的时间。单位为秒，精度是毫秒。</td>
</tr>
<tr>
<td>pipe</td>
<td>表示请求是否通过HTTP流水线（pipelined）发送。通过HTTP流水线发送则pipe值为<code>p</code>，否则为<code>.</code>。</td>
</tr>
<tr>
<td>http_host</td>
<td>请求的url地址（目标url地址）的host</td>
</tr>
<tr>
<td>host</td>
<td>等同于$http_host</td>
</tr>
<tr>
<td>http_referer</td>
<td>表示从哪个页面链接访问过来的。</td>
</tr>
<tr>
<td>http_user_agent</td>
<td>表示客户端浏览器相关信息，前后必须加上双引号。</td>
</tr>
<tr>
<td>request_length</td>
<td>表示请求的长度。包括请求行，请求头和请求正文。</td>
</tr>
<tr>
<td>request_time</td>
<td>表示请求处理时间，单位为秒，精度为毫秒。从读入客户端的第一个字节开始，直到把最后一个字符发送给客户端后进行日志写入为止。</td>
</tr>
<tr>
<td>[$time_local]</td>
<td>表示通用日志格式下的本地时间，前后必须加上中括号。</td>
</tr>
<tr>
<td>upstream_addr</td>
<td>集群轮询地址</td>
</tr>
<tr>
<td>upstream_response_time</td>
<td>指从Nginx向后端（php-cgi)建立连接开始到接受完数据然后关闭连接为止的时间</td>
</tr>
<tr>
<td>upstream_connect_time</td>
<td>与服务器连接所花费的时间</td>
</tr>
<tr>
<td>upstream_status</td>
<td>upstream状态</td>
</tr>
<tr>
<td>uri</td>
<td>请求中的当前URI(不带请求参数，参数位于$args)，不同于浏览器传递的$request_uri的值，它可以通过内部重定向，或者使用index指令进行修改。</td>
</tr>
<tr>
<td>document_uri</td>
<td>等同于$uri</td>
</tr>
<tr>
<td>request_uri</td>
<td>比$uri多了参数，即$uri+$args</td>
</tr>
<tr>
<td>http_x_forwarded_for</td>
<td>如果使用了代理，这个参数会记录代理服务器的ip和客户端的ip</td>
</tr>
<tr>
<td>schema</td>
<td>协议</td>
</tr>
<tr>
<td>server_name</td>
<td>虚拟主机名称</td>
</tr>
<tr>
<td>server_port</td>
<td>服务器端口</td>
</tr>
<tr>
<td>server_protocol</td>
<td>服务器协议</td>
</tr>
<tr>
<td>ssl_cipher</td>
<td>交换数据中的算法</td>
</tr>
<tr>
<td>ssl_protocol</td>
<td>SSL协议版本</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>nodejs版本管理工具-nvm</title>
    <url>/posts/nvm2c/</url>
    <content><![CDATA[<p>nvm全英文也叫node.js version management，是一个nodejs的版本管理工具。nvm和n都是node.js版本管理工具，为了解决node.js各种版本存在不兼容现象可以通过它可以安装和切换不同版本的node.js。</p>
<span id="more"></span>



<h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;github.com&#x2F;nvm-sh&#x2F;nvm.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><pre class="line-numbers language-none"><code class="language-none">curl -o- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;nvm-sh&#x2F;nvm&#x2F;v0.39.7&#x2F;install.sh | bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>或者</p>
<pre class="line-numbers language-none"><code class="language-none">wget -qO- https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;nvm-sh&#x2F;nvm&#x2F;v0.39.7&#x2F;install.sh | bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>运行上述任一命令都会下载脚本并运行它。该脚本将 nvm 存储库克隆到<del>&#x2F;.nvm，并尝试将下面代码片段中的源行添加到正确的配置文件（</del>&#x2F;.bash_profile、<del>&#x2F;.zshrc、</del>&#x2F;.profile或~&#x2F;.bashrc）</p>
<p>刷新</p>
<pre class="line-numbers language-none"><code class="language-none">source ~&#x2F;.bashrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="nvm常用命令"><a href="#nvm常用命令" class="headerlink" title="nvm常用命令"></a>nvm常用命令</h2><p>nvm install 14.13.2<br>nvm uninstall 14.13.2     &#x2F;&#x2F; 移除 node 14.13.2<br>nvm use 14.13.2           &#x2F;&#x2F; 使用 node 14.13.2<br>nvm ls                   &#x2F;&#x2F; 查看目前已安装的 node 及当前所使用的 node<br>nvm ls-remote            &#x2F;&#x2F; 查看目前线上所能安装的所有 node 版本<br>nvm alias default 14.13.2 &#x2F;&#x2F; 使用 14.13.2 作为预设使用的 node 版本</p>
<h2 id="nvm-安装的node位置"><a href="#nvm-安装的node位置" class="headerlink" title="nvm 安装的node位置"></a>nvm 安装的node位置</h2><p>npm config list<br>期望输出</p>
<pre class="line-numbers language-none"><code class="language-none">; node bin location &#x3D; &#x2F;root&#x2F;.nvm&#x2F;versions&#x2F;node&#x2F;v16.20.1&#x2F;bin&#x2F;node<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="Nodejs镜像源配置"><a href="#Nodejs镜像源配置" class="headerlink" title="Nodejs镜像源配置"></a>Nodejs镜像源配置</h2><p>vim  ~&#x2F;.bashrc</p>
<pre class="line-numbers language-none"><code class="language-none">export NVM_NODEJS_ORG_MIRROR&#x3D;https:&#x2F;&#x2F;npmmirror.com&#x2F;mirrors&#x2F;node&#x2F;
export NVM_IOJS_ORG_MIRROR&#x3D;https:&#x2F;&#x2F;npmmirror.com&#x2F;mirrors&#x2F;iojs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="npm设置国内镜像源"><a href="#npm设置国内镜像源" class="headerlink" title="npm设置国内镜像源"></a>npm设置国内镜像源</h2><p>淘宝源</p>
<pre class="line-numbers language-none"><code class="language-none">npm config set registry https:&#x2F;&#x2F;npmmirror.com
npm config set disturl https:&#x2F;&#x2F;npmmirror.com&#x2F;dist
或
npm config set registry https:&#x2F;&#x2F;registry.npmmirror.com
npm config set disturl https:&#x2F;&#x2F;registry.npmmirror.com&#x2F;dist<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>腾讯源</p>
<pre class="line-numbers language-none"><code class="language-none">腾讯内网
npm config set registry http:&#x2F;&#x2F;mirrors.tencentyun.com&#x2F;npm&#x2F;
yarn config set registry http:&#x2F;&#x2F;mirrors.tencentyun.com&#x2F;npm&#x2F;
腾讯公网
npm config set registry http:&#x2F;&#x2F;mirrors.tencent.com&#x2F;npm<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-none"><code class="language-none">关闭SSL验证
npm config set strict-ssl false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h3 id="通过环境变量设置镜像源"><a href="#通过环境变量设置镜像源" class="headerlink" title="通过环境变量设置镜像源"></a>通过环境变量设置镜像源</h3><pre class="line-numbers language-none"><code class="language-none"># 设置环境变量  
export NPM_CONFIG_DISTURL&#x3D;https:&#x2F;&#x2F;registry.npmmirror.com&#x2F;dist  
export NPM_CONFIG_REGISTRY&#x3D;https:&#x2F;&#x2F;registry.npmmirror.com&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<h2 id="Nodejs版本自动切换"><a href="#Nodejs版本自动切换" class="headerlink" title="Nodejs版本自动切换"></a>Nodejs版本自动切换</h2><p>在项目根目录下创建一个<code>.nvmrc</code>文件,里面写入期望的nodejs版本</p>
<pre class="line-numbers language-none"><code class="language-none">node -v &gt; .nvmrc<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>Mac   在 <code>.zshrc</code> 加入一个钩子：</p>
<pre class="line-numbers language-none"><code class="language-none">autoload -U add-zsh-hook
 load-nvmrc() &#123;
   if [[ -f .nvmrc &amp;&amp; -r .nvmrc ]]; then
     nvm use
   fi
 &#125;
add-zsh-hook chpwd load-nvmrc
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>linux bash shell </p>
<pre class="line-numbers language-none"><code class="language-none"># 在每次切换目录时检查是否存在 .nvmrc 文件并切换 Node.js 版本
cd() &#123;
  builtin cd &quot;$@&quot; &amp;&amp; load_nvmrc
&#125;

load_nvmrc() &#123;
  # 如果目录下存在.nvmrc，则使用.nvmrc指定的nodejs版本。如果没有，则使用默认的v18.18.2版本
  if [[ -f .nvmrc &amp;&amp; -r .nvmrc ]]; then
    nvm use
  else
    nvm use v18.18.2
  fi
&#125;

# 在每次进入命令提示符之前执行 load_nvmrc
PROMPT_COMMAND&#x3D;&quot;load_nvmrc&quot;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="为每个nodejs安装yarn"><a href="#为每个nodejs安装yarn" class="headerlink" title="为每个nodejs安装yarn"></a>为每个nodejs安装yarn</h2><p>在使用 <code>nvm</code> 管理的 Node.js 环境下，可以为每个 Node.js 版本安装独立的 <code>yarn</code>。以下是具体步骤</p>
<ol>
<li><strong>切换到目标 Node.js 版本</strong></li>
</ol>
<p>使用 <code>nvm use</code> 切换到需要的 Node.js 版本：</p>
<pre class="line-numbers language-none"><code class="language-none">nvm use &lt;node_version&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>例如：</p>
<pre class="line-numbers language-none"><code class="language-none">nvm use 16.20.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>如果没有安装目标版本，可以先安装：</p>
<pre class="line-numbers language-none"><code class="language-none">nvm install &lt;node_version&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<hr>
<ol start="2">
<li><strong>安装 <code>yarn</code></strong></li>
</ol>
<p>使用 <code>npm</code> 安装 <code>yarn</code>：</p>
<pre class="line-numbers language-none"><code class="language-none">npm install -g yarn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><p>这会在当前 Node.js 版本的环境中安装 <code>yarn</code>，并将其关联到该版本的 <code>node_modules</code> 目录。</p>
</li>
<li><p>安装完成后，可以验证：</p>
<pre class="line-numbers language-none"><code class="language-none">yarn --version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>nvm</tag>
      </tags>
  </entry>
  <entry>
    <title>iterm2快捷键</title>
    <url>/posts/iterm3/</url>
    <content><![CDATA[<p>iterm2常用快捷键</p>
<span id="more"></span>



]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>mac快捷键</title>
    <url>/posts/ca0f/</url>
    <content><![CDATA[<p>mac常用快捷键</p>
<span id="more"></span>



<h1 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h1><h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><h3 id="复制、剪切、粘贴"><a href="#复制、剪切、粘贴" class="headerlink" title="复制、剪切、粘贴"></a>复制、剪切、粘贴</h3><h2 id><a href="#" class="headerlink" title></a></h2><pre class="line-numbers language-none"><code class="language-none">复制：command + c
剪切：command + x
粘贴：command + v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="撤销、重做"><a href="#撤销、重做" class="headerlink" title="撤销、重做"></a>撤销、重做</h3><pre class="line-numbers language-none"><code class="language-none">撤销：command + z
重做：command + shift + z<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="全选、取消选择"><a href="#全选、取消选择" class="headerlink" title="全选、取消选择"></a>全选、取消选择</h3><pre class="line-numbers language-none"><code class="language-none">全选：command + a
取消选择：command + shift + a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h3><pre class="line-numbers language-none"><code class="language-none">查找：command + f
替换：command + option + f<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h2 id="窗口快捷键"><a href="#窗口快捷键" class="headerlink" title="窗口快捷键"></a>窗口快捷键</h2><p>1、切换应用程序</p>
<pre class="line-numbers language-none"><code class="language-none">command + tab<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>2、最大化窗口</p>
<pre class="line-numbers language-none"><code class="language-none">最大化当前窗口：command + control + F
最大化所有窗口：option + 点击窗口最大化按钮<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>3、窗口移动、重置大小</p>
<pre class="line-numbers language-none"><code class="language-none">窗口移动：command + 鼠标拖拽窗口
重置大小：option + 点击红色关闭按钮<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h2 id="系统快捷键"><a href="#系统快捷键" class="headerlink" title="系统快捷键"></a>系统快捷键</h2><h3 id="截屏、录屏"><a href="#截屏、录屏" class="headerlink" title="截屏、录屏"></a>截屏、录屏</h3><pre class="line-numbers language-none"><code class="language-none">截全屏：command + shift + 3
自定义截屏：command + shift + 4
录屏：command + shift + 5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<h1 id="item"><a href="#item" class="headerlink" title="item"></a>item</h1><h2 id="新建窗口"><a href="#新建窗口" class="headerlink" title="新建窗口"></a>新建窗口</h2><pre class="line-numbers language-none"><code class="language-none">command + n<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="tab"><a href="#tab" class="headerlink" title="tab"></a>tab</h2><h3 id="新建tab"><a href="#新建tab" class="headerlink" title="新建tab"></a>新建tab</h3><pre class="line-numbers language-none"><code class="language-none">command + t<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h3 id="选择tab"><a href="#选择tab" class="headerlink" title="选择tab"></a>选择tab</h3><pre class="line-numbers language-none"><code class="language-none">command + shift + ]
command + shift + [<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="移动tab"><a href="#移动tab" class="headerlink" title="移动tab"></a>移动tab</h3><pre class="line-numbers language-none"><code class="language-none">command + shift + option + ]
command + shift + option + [<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>链路监控-skywalking</title>
    <url>/posts/skf69/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><h1 id="Java-agent-探针"><a href="#Java-agent-探针" class="headerlink" title="Java agent 探针"></a>Java agent 探针</h1><h2 id="Agent的可配置属性列表"><a href="#Agent的可配置属性列表" class="headerlink" title="Agent的可配置属性列表"></a>Agent的可配置属性列表</h2><p>这里是<code>agent/config/agent.config</code>中支持的属性列表。</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td><code>agent.namespace</code></td>
<td>命名空间，用于隔离跨进程传播的header。如果进行了配置，header将为<code>HeaderName:Namespace</code>.</td>
<td>未设置</td>
</tr>
<tr>
<td><code>agent.service_name</code></td>
<td>在SkyWalking UI中展示的服务名。5.x版本对应Application，6.x版本对应Service。 建议：为每个服务设置个唯一的名字，服务的多个服务实例为同样的服务名</td>
<td><code>Your_ApplicationName</code></td>
</tr>
<tr>
<td><code>agent.sample_n_per_3_secs</code></td>
<td>负数或0表示不采样，默认不采样。SAMPLE_N_PER_3_SECS表示每3秒采样N条。</td>
<td>未设置</td>
</tr>
<tr>
<td><code>agent.authentication</code></td>
<td>鉴权是否开启取决于后端的配置，可查看application.yml的详细描述。对于大多数的场景，需要后端对鉴权进行扩展。目前仅实现了基本的鉴权功能。</td>
<td>未设置</td>
</tr>
<tr>
<td><code>agent.span_limit_per_segment</code></td>
<td>单个segment中的span的最大个数。通过这个配置项，Skywalking可评估应用程序内存使用量。</td>
<td>未设置</td>
</tr>
<tr>
<td><code>agent.ignore_suffix</code></td>
<td>如果这个集合中包含了第一个span的操作名，这个segment将会被忽略掉。</td>
<td>未设置</td>
</tr>
<tr>
<td><code>agent.is_open_debugging_class</code></td>
<td>如果为true，skywalking会将所有经Instrument转换过的类文件保存到<code>/debugging</code>文件夹下。Skywalking团队会要求你提供这些类文件以解决兼容性问题。</td>
<td>未设置</td>
</tr>
<tr>
<td><code>agent.cause_exception_depth</code></td>
<td>在记录异常信息的时候, 探针需要记录的堆栈深度.</td>
<td>5</td>
</tr>
<tr>
<td><code>agent.force_reconnection_period</code></td>
<td>grpc的强制重连周期，基于grpc_channel_check_interval.</td>
<td><code>1</code></td>
</tr>
<tr>
<td><code>agent.operation_name_threshold</code></td>
<td>设置操作名不建议超过最大长度(190).</td>
<td><code>150</code></td>
</tr>
<tr>
<td><code>agent.keep_tracing</code></td>
<td>如果该值为 <code>true</code>，即使后台不可用，也要保持跟踪.</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>osinfo.ipv4_list_size</code></td>
<td>限制ipv4列表的长度.</td>
<td><code>10</code></td>
</tr>
<tr>
<td>&#96;collector.grpc_channel_check_interval</td>
<td>检查grpc的channel状态的时间间隔。</td>
<td><code>30</code></td>
</tr>
<tr>
<td><code>collector.backend_service</code></td>
<td>接收skywalking trace数据的后端地址</td>
<td><code>127.0.0.1:11800</code></td>
</tr>
<tr>
<td><code>collector.heartbeat_period</code></td>
<td>探针心跳报告时间. 单位秒.</td>
<td><code>30</code></td>
</tr>
<tr>
<td><code>collector.grpc_upstream_timeout</code></td>
<td>grpc客户端向上游发送数据时超时多长时间. 单位秒.</td>
<td><code>30</code> 秒</td>
</tr>
<tr>
<td><code>collector.get_profile_task_interval</code></td>
<td>嗅探器获取配置文件任务列表间隔.</td>
<td><code>20</code></td>
</tr>
<tr>
<td><code>logging.level</code></td>
<td>日志级别。默认为debug。</td>
<td><code>DEBUG</code></td>
</tr>
<tr>
<td><code>logging.file_name</code></td>
<td>日志文件名</td>
<td><code>skywalking-api.log</code></td>
</tr>
<tr>
<td><code>logging.output</code></td>
<td>日志输出. 默认是文件. 使用控制台意味着输出到标准输出.</td>
<td><code>FILE</code></td>
</tr>
<tr>
<td><code>logging.dir</code></td>
<td>日志目录。默认为空串，表示使用”system.out”输出日志。</td>
<td><code>&quot;&quot;</code></td>
</tr>
<tr>
<td><code>logging.pattern</code></td>
<td>日志格式. 所有的转换说明符:  * <code>%level</code> means log level.  * <code>%timestamp</code> 表示现在的时间格式 <code>yyyy-MM-dd HH:mm:ss:SSS</code>.  * <code>%thread</code> 表示当前线程的名称.  * <code>%msg</code> 表示用户记录的某些消息.  * <code>%class</code> 表示TargetClass的SimpleName.  * <code>%throwable</code> 表示用户抛出的异常.  * <code>%agent_name</code> 表示 <code>agent.service_name</code></td>
<td><code>%level %timestamp %thread %class : %msg %throwable</code></td>
</tr>
<tr>
<td><code>logging.max_file_size</code></td>
<td>日志文件的最大大小。当日志文件大小超过这个数，归档当前的日志文件，将日志写入到新文件。</td>
<td><code>300 * 1024 * 1024</code></td>
</tr>
<tr>
<td><code>logging.max_history_files</code></td>
<td>The max history log files. When rollover happened, if log files exceed this number,then the oldest file will be delete. Negative or zero means off, by default.</td>
<td><code>-1</code></td>
</tr>
<tr>
<td><code>jvm.buffer_size</code></td>
<td>收集JVM信息的buffer的大小。</td>
<td><code>60 * 10</code></td>
</tr>
<tr>
<td><code>buffer.channel_size</code></td>
<td>buffer的channel大小。</td>
<td><code>5</code></td>
</tr>
<tr>
<td><code>buffer.buffer_size</code></td>
<td>buffer的大小</td>
<td><code>300</code></td>
</tr>
<tr>
<td><code>profile.active</code></td>
<td>如果为<code>true</code>，SkyWalking代理将在用户创建新的配置文件任务时启用配置文件. 否则禁用概要.</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>profile.max_parallel</code></td>
<td>并行监控段计数</td>
<td><code>5</code></td>
</tr>
<tr>
<td><code>profile.duration</code></td>
<td>监控段最大时间(分钟)，如果当前监控段时间超出限制，则停止.</td>
<td><code>10</code></td>
</tr>
<tr>
<td><code>profile.dump_max_stack_depth</code></td>
<td>最大线程转储的堆栈深度</td>
<td><code>500</code></td>
</tr>
<tr>
<td><code>profile.snapshot_transport_buffer_size</code></td>
<td>快照传输到后端缓冲区的大小</td>
<td><code>50</code></td>
</tr>
<tr>
<td><code>plugin.mongodb.trace_param</code></td>
<td>如果为true，记录所有访问MongoDB的参数信息。默认为false，表示仅记录操作名，不记录参数信息。</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>plugin.elasticsearch.trace_dsl</code></td>
<td>如果为true，记录所有访问ElasticSearch的DSL信息。默认为false。</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>plugin.springmvc.use_qualified_name_as_endpoint_name</code></td>
<td>如果为true，endpoint的name为方法的全限定名，而不是请求的URL。默认为false。</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>plugin.toolit.use_qualified_name_as_operation_name</code></td>
<td>如果为true，operation的name为方法的全限定名，而不是给定的operation name。默认为false。</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>plugin.mysql.trace_sql_parameters</code></td>
<td>如果设置为 true, SQL 查询 (典型的是 <code>java.sql.PreparedStatement</code>) 的参数也会被采集.</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>plugin.mysql.sql_parameters_max_length</code></td>
<td>如果设置为正整数, 收集的 SQL 参数 <code>db.sql.parameters</code> 会被截断到这个长度, 否则会被完整保存, 这可能会导致性能问题.</td>
<td><code>512</code></td>
</tr>
<tr>
<td><code>plugin.solrj.trace_statement</code></td>
<td>如果为 true, 追踪 Solr 查询请求中的所有查询参数(包括 deleteByIds 和 deleteByQuery) 默认为 false.</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>plugin.solrj.trace_ops_params</code></td>
<td>如果为 true, 追踪 Solr 查询中所有操作参数, 默认为 false.</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>plugin.peer_max_length</code></td>
<td>Peer 描述最大限制.</td>
<td><code>200</code></td>
</tr>
<tr>
<td><code>plugin.mongodb.filter_length_limit</code></td>
<td>如果设置为正数, <code>WriteRequest.params</code> 将被截短到这个长度, 否则它将被完全保存，这可能会导致性能问题.</td>
<td><code>256</code></td>
</tr>
<tr>
<td><code>plugin.postgresql.trace_sql_parameters</code></td>
<td>如果设置为true，将收集sql的参数(通常是 <code>java.sql.PreparedStatement</code>).</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>plugin.postgresql.sql_parameters_max_length</code></td>
<td>如果设置为正数, <code>db.sql.parameters</code> 将被截断到这个长度，否则它将被完全保存，这可能会导致性能问题.</td>
<td><code>512</code></td>
</tr>
<tr>
<td><code>plugin.mariadb.trace_sql_parameters</code></td>
<td>如果设置为true，将收集sql的参数(通常是 <code>java.sql.PreparedStatement</code>).</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>plugin.mariadb.sql_parameters_max_length</code></td>
<td>如果设置为正数，<code>db.sql</code> 将被截断到这个长度，否则它将被完全保存，这可能会导致性能问题.</td>
<td><code>512</code></td>
</tr>
<tr>
<td><code>plugin.light4j.trace_handler_chain</code></td>
<td>如果为<code>true</code>，请跟踪属于请求的Light4J处理程序链的所有中间件&#x2F;业务处理程序.</td>
<td>false</td>
</tr>
<tr>
<td><code>plugin.opgroup.*</code></td>
<td>支持在不同插件中自定义组规则的操作名. 请阅读 <a href="https://skyapm.github.io/document-cn-translation-of-skywalking/zh/8.0.0/setup/service-agent/java-agent/op_name_group_rule.html">Group rule supported plugins</a></td>
<td>Not set</td>
</tr>
<tr>
<td><code>plugin.springtransaction.simplify_transaction_definition_name</code></td>
<td>如果为<code>true</code>，事务定义名称将被简化.</td>
<td>false</td>
</tr>
<tr>
<td><code>plugin.jdkthreading.threading_class_prefixes</code></td>
<td>线程类 (<code>java.lang.Runnable</code> and <code>java.util.concurrent.Callable</code>) 及其子类(包括任何名称匹配 <code>THREADING_CLASS_PREFIXES</code> (以 <code>，</code> 分隔)的匿名内部类) 将被检测, 确保只指定短小的前缀，就像您预期要测试的一样, (<code>java.</code> 和 <code>javax.</code> 会因安全问题而被忽略)</td>
<td>Not set</td>
</tr>
<tr>
<td><code>plugin.tomcat.collect_http_params</code></td>
<td>这个配置项控制Tomcat插件是否应该收集请求的参数. 同样，在概要追踪中隐式激活.</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>plugin.springmvc.collect_http_params</code></td>
<td>这个配置项控制SpringMVC插件是否应该收集请求的参数, 当您的Spring应用程序基于Tomcat时, 只需要设置 <code>plugin.tomcat.collect_http_params</code> 或 <code>plugin.springmvc.collect_http_params</code> 之一. 同样，在概要追踪中隐式激活.</td>
<td><code>false</code></td>
</tr>
<tr>
<td><code>plugin.http.http_params_length_threshold</code></td>
<td>当启用 <code>COLLECT_HTTP_PARAMS</code>时，要保留多少字符并将其发送到OAP后端，请使用负值来保留和发送完整的参数. 添加这个配置项是为了提高性能.</td>
<td><code>1024</code></td>
</tr>
<tr>
<td><code>correlation.element_max_number</code></td>
<td>关联上下文的最大元素数.</td>
<td><code>3</code></td>
</tr>
<tr>
<td><code>correlation.value_max_length</code></td>
<td>关联上下文元素的最大值长度.</td>
<td><code>128</code></td>
</tr>
</tbody></table>
<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="可选的插件"><a href="#可选的插件" class="headerlink" title="可选的插件"></a>可选的插件</h2><p>Java agent的所有插件都是可插拔的。在agent或第三方仓库的<code>optional-plugins</code> 文件夹下提供了可选的插件。 想要使用可选插件，你需要将对应插件移动到<code>/plugins</code>文件夹下。</p>
<h2 id="Bootstrap-类插件"><a href="#Bootstrap-类插件" class="headerlink" title="Bootstrap 类插件"></a>Bootstrap 类插件</h2><p>由于意外风险，所有 Bootstrap 插件都是可选的。Bootstrap 插件在 <code>bootstrap-plugins</code> 文件夹中提供. 若使用这些插件，您需要将目标插件 jar 文件放入 <code>/plugins</code> 中.</p>
<p>现在，我们有以下已知的 Bootstrap 插件.</p>
<ul>
<li>JDK HttpURLConnection 插件. Agent 兼容 JDK 1.6+</li>
<li>JDK Callable and Runnable 插件. Agent 兼容 1.6+</li>
</ul>
<h2 id="-1"><a href="#-1" class="headerlink" title></a></h2><h2 id="设置覆盖"><a href="#设置覆盖" class="headerlink" title="设置覆盖"></a>设置覆盖</h2><p>默认情况下，SkyWalking提供<code>agent.config</code>文件给代理。</p>
<p>设置覆盖意味着最终用户可以通过使用系统属性或代理选项来覆盖这些配置文件中的设置。</p>
<h3 id="系统属性"><a href="#系统属性" class="headerlink" title="系统属性"></a>系统属性</h3><p>在配置文件中使用 <code>skywalking. + key</code> 作为系统属性键，以覆盖该值。</p>
<ul>
<li>为什么需要这个前缀？</li>
</ul>
<p>代理系统属性和环境与目标应用程序共享，这个前缀可以避免变量冲突。</p>
<ul>
<li>示例</li>
</ul>
<p>通过以下方式覆盖 <code>agent.application_code</code>。</p>
<pre class="line-numbers language-none"><code class="language-none">bashCopy code
-Dskywalking.agent.application_code&#x3D;31200<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="代理选项"><a href="#代理选项" class="headerlink" title="代理选项"></a>代理选项</h3><p>在JVM参数中在代理路径后添加属性。</p>
<pre class="line-numbers language-none"><code class="language-none">bashCopy code
-javaagent:&#x2F;path&#x2F;to&#x2F;skywalking-agent.jar&#x3D;[option1]&#x3D;[value1],[option2]&#x3D;[value2]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li>示例</li>
</ul>
<p>通过以下方式覆盖 <code>agent.application_code</code> 和 <code>logging.level</code>。</p>
<pre class="line-numbers language-none"><code class="language-none">bashCopy code
-javaagent:&#x2F;path&#x2F;to&#x2F;skywalking-agent.jar&#x3D;agent.application_code&#x3D;31200,logging.level&#x3D;debug<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li>特殊字符</li>
</ul>
<p>如果选项或值中有分隔符(,或&#x3D;)，应该用引号括起来。</p>
<pre class="line-numbers language-none"><code class="language-none">bashCopy code
-javaagent:&#x2F;path&#x2F;to&#x2F;skywalking-agent.jar&#x3D;agent.ignore_suffix&#x3D;&#39;.jpg,.jpeg&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="系统环境变量"><a href="#系统环境变量" class="headerlink" title="系统环境变量"></a>系统环境变量</h3><ul>
<li>示例</li>
</ul>
<p>通过以下方式覆盖 <code>agent.application_code</code> 和 <code>logging.level</code>。</p>
<pre class="line-numbers language-none"><code class="language-none">bashCopy code
# UI中的服务名称
agent.service_name&#x3D;$&#123;SW_AGENT_NAME:Your_ApplicationName&#125;

# 日志级别
logging.level&#x3D;$&#123;SW_LOGGING_LEVEL:INFO&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果操作系统中存在名为 <code>SW_AGENT_NAME</code> 的环境变量且其值为 <code>skywalking-agent-demo</code>，则此处 <code>agent.service_name</code> 的值将被覆盖为 <code>skywalking-agent-demo</code>，否则将设置为 <code>Your_ApplicationName</code>。</p>
<p>另外，还支持占位符嵌套，如<code>$&#123;SW_AGENT_NAME:$&#123;ANOTHER_AGENT_NAME:Your_ApplicationName&#125;&#125;</code>。在这种情况下，如果 <code>SW_AGENT_NAME</code> 环境变量不存在，但 <code>ANOTHER_AGENT_NAME</code> 环境变量存在且其值为 <code>skywalking-agent-demo</code>，则此处 <code>agent.service_name</code> 的值将被覆盖为 <code>skywalking-agent-demo</code>，否则将设置为 <code>Your_ApplicationName</code>。</p>
<h3 id="覆盖优先级"><a href="#覆盖优先级" class="headerlink" title="覆盖优先级"></a>覆盖优先级</h3><p>代理选项 &gt; 系统属性(-D) &gt; 系统环境变量 &gt; 配置文件</p>
<h2 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h2><h3 id="采样率配置"><a href="#采样率配置" class="headerlink" title="采样率配置"></a>采样率配置</h3><p>采样率配置：agent.sample_n_per_3_secs&#x3D;${SW_AGENT_SAMPLE:-1}</p>
<ul>
<li><p>配置文件配置</p>
<p>配置文件路径：agent&#x2F;config&#x2F;agent.config</p>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">修改采样率。**agent.sample_n_per_3_secs  表示设置每3秒可收集的链路数据（TraceSegment）的数量。负或零表示全部采样，默认全部采样。
示例：
假设您需要在3秒内采集1500个 TraceSegment ，可以设置为：
agent.sample_n_per_3_secs&#x3D;$&#123;SW_AGENT_SAMPLE:1500&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<ul>
<li>通过环境变量配置</li>
</ul>
<p>新增环境变量 export SW_AGENT_SAMPLE&#x3D;15000</p>
<h3 id="Agent日志配置"><a href="#Agent日志配置" class="headerlink" title="Agent日志配置"></a>Agent日志配置</h3><pre class="line-numbers language-none"><code class="language-none">agent&#x2F;config&#x2F;agent.config
- logging.level  日志级别。默认为debug。
- logging.max_file_size 日志文件的最大大小，默认300M
- logging.max_history_files  最大历史日志文件，默认无限制。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="忽略指定端点"><a href="#忽略指定端点" class="headerlink" title="忽略指定端点"></a>忽略指定端点</h3><p>不是所有的接口都需要采集，所以需要排除部分接口，比如健康检查接口，Eureka心跳信息等.这样可以节省不必要的数据采集和存储</p>
<p>将 optional-plugins&#x2F;apm-trace-ignore-plugin-8.13.0.jar 拷贝到plugins&#x2F; </p>
<pre class="line-numbers language-none"><code class="language-none">cp optional-plugins&#x2F;apm-trace-ignore-plugin-8.13.0.jar plugins&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>通过系统属性配置</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">-Dskywalking.trace.ignore_path&#x3D;&#x2F;actuator&#x2F;health<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>通过配置文件</li>
</ul>
<p>在<code>config</code>目录下创建<code>apm-trace-ignore-plugin.config</code>文件并添加如下配置激活插件：</p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">trace.ignore_path=/your/path/1/**,/your/path/2/** ➊<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>➊ 中的路径配置规则支持<code>Ant Path</code>匹配风格，比如： <code>/path/*</code>, <code>/path/**</code>, <code>/path/?</code>。匹配的Path路径将不会被记录。</p>
]]></content>
      <categories>
        <category>监控</category>
        <category>apm</category>
      </categories>
      <tags>
        <tag>qexo</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>es性能调优</title>
    <url>/posts/ab8e/</url>
    <content><![CDATA[<h1 id="一、配置文件调优"><a href="#一、配置文件调优" class="headerlink" title="一、配置文件调优"></a>一、配置文件调优</h1><p>elasticsearch.yml</p>
<h2 id="内存锁定"><a href="#内存锁定" class="headerlink" title="内存锁定"></a><strong>内存锁定</strong></h2><p>bootstrap.memory_lock：true 锁定堆内存；</p>
<p><strong>zen.discovery</strong></p>
<p>ES是一个P2P类型的分布式系统，使用gossip协议，集群的任意请求都可以发送到集群的任一节点，然后es内部会找到需要转发的节点，并且与之进行通信。在es1.x的版本，es默认是开启组播，启动es之后，可以快速将局域网内集群名称，默认端口的相同实例加入到一个大的集群，后续再es2.x之后，都调整成了单播，避免安全问题和网络风暴；单播discovery.zen.ping.unicast.hosts，建议写入集群内所有的节点及端口，如果新实例加入集群，新实例只需要写入当前集群的实例，即可自动加入到当前集群，之后再处理原实例的配置即可，新实例加入集群，不需要重启原有实例；节点zen相关配置：discovery.zen.ping_timeout：判断master选举过程中，发现其他node存活的超时设置，主要影响选举的耗时，参数仅在加入或者选举 master 主节点的时候才起作用discovery.zen.join_timeout：节点确定加入到集群中，向主节点发送加入请求的超时时间，默认为3sdiscovery.zen.minimum_master_nodes：参与master选举的最小节点数，当集群能够被选为master的节点数量小于最小数量时，集群将无法正常选举。</p>
<h2 id="故障检测（-fault-detection-）"><a href="#故障检测（-fault-detection-）" class="headerlink" title="故障检测（ fault detection ）"></a><strong>故障检测（ fault detection ）</strong></h2><p>两种情况下回进行故障检测，第一种是由master向集群的所有其他节点发起ping，验证节点是否处于活动状态；第二种是：集群每个节点向master发起ping，判断master是否存活，是否需要发起选举。故障检测需要配置以下设置使用形如：discovery.zen.fd.ping_interval 节点被ping的频率，默认为1s。discovery.zen.fd.ping_timeout 等待ping响应的时间，默认为 30s，运行的集群中，master 检测所有节点，以及节点检测 master 是否正常。discovery.zen.fd.ping_retries ping失败&#x2F;超时多少导致节点被视为失败，默认为3。</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.x/modules-discovery-zen.html">https://www.elastic.co/guide/en/elasticsearch/reference/6.x/modules-discovery-zen.html</a></p>
<h2 id="队列数量"><a href="#队列数量" class="headerlink" title="队列数量"></a><strong>队列数量</strong></h2><p>不建议盲目加大es的队列数量，如果是偶发的因为数据突增，导致队列阻塞，加大队列size可以使用内存来缓存数据，如果是持续性的数据阻塞在队列，加大队列size除了加大内存占用，并不能有效提高数据写入速率，反而可能加大es宕机时候，在内存中可能丢失的上数据量。哪些情况下，加大队列size呢？GET &#x2F;_cat&#x2F;thread_pool，观察api中返回的queue和rejected，如果确实存在队列拒绝或者是持续的queue，可以酌情调整队列size。</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.x/modules-threadpool.html">https://www.elastic.co/guide/en/elasticsearch/reference/6.x/modules-threadpool.html</a></p>
<h2 id="内存使用"><a href="#内存使用" class="headerlink" title="内存使用"></a><strong>内存使用</strong></h2><p>设置indices的内存熔断相关参数，根据实际情况进行调整，防止写入或查询压力过高导致OOM，indices.breaker.total.limit: 50%，集群级别的断路器，默认为jvm堆的70%；indices.breaker.request.limit: 10%，单个request的断路器限制，默认为jvm堆的60%；indices.breaker.fielddata.limit: 10%，fielddata breaker限制，默认为jvm堆的60%。</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.x/circuit-breaker.html">https://www.elastic.co/guide/en/elasticsearch/reference/6.x/circuit-breaker.html</a></p>
<p>根据实际情况调整查询占用cache，避免查询cache占用过多的jvm内存，参数为静态的，需要在每个数据节点配置。indices.queries.cache.size: 5%，控制过滤器缓存的内存大小，默认为10%。接受百分比值，5%或者精确值，例如512mb。</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.x/query-cache.html">https://www.elastic.co/guide/en/elasticsearch/reference/6.x/query-cache.html</a></p>
<h2 id="创建shard"><a href="#创建shard" class="headerlink" title="创建shard"></a><strong>创建shard</strong></h2><p>如果集群规模较大，可以阻止新建shard时扫描集群内全部shard的元数据，提升shard分配速度。cluster.routing.allocation.disk.include_relocations: false，默认为true。</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.x/disk-allocator.html">https://www.elastic.co/guide/en/elasticsearch/reference/6.x/disk-allocator.html</a></p>
<h1 id="二、系统层面调优"><a href="#二、系统层面调优" class="headerlink" title="二、系统层面调优"></a>二、系统层面调优</h1><h2 id="jdk版本"><a href="#jdk版本" class="headerlink" title="jdk版本"></a><strong>jdk版本</strong></h2><p>当前根据官方建议，选择匹配的jdk版本；</p>
<h2 id="jdk内存配置"><a href="#jdk内存配置" class="headerlink" title="jdk内存配置"></a><strong>jdk内存配置</strong></h2><p>首先，-Xms和-Xmx设置为相同的值，避免在运行过程中再进行内存分配，同时，如果系统内存小于64G，建议设置略小于机器内存的一半，剩余留给系统使用。同时，jvm heap建议不要超过32G（不同jdk版本具体的值会略有不同），否则jvm会因为内存指针压缩导致内存浪费，详见：<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/heap-sizing.html">https://www.elastic.co/guide/cn/elasticsearch/guide/current/heap-sizing.html</a></p>
<h2 id="交换分区"><a href="#交换分区" class="headerlink" title="交换分区"></a><strong>交换分区</strong></h2><p>关闭交换分区，防止内存发生交换导致性能下降（部分情况下，宁死勿慢）swapoff -a</p>
<h2 id="文件句柄"><a href="#文件句柄" class="headerlink" title="文件句柄"></a><strong>文件句柄</strong></h2><p>Lucene 使用了 大量的 文件。 同时，Elasticsearch 在节点和 HTTP 客户端之间进行通信也使用了大量的套接字，所有这一切都需要足够的文件描述符，默认情况下，linux默认运行单个进程打开1024个文件句柄，这显然是不够的，故需要加大文件句柄数ulimit -n 65536</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.5/setting-system-settings.html">https://www.elastic.co/guide/en/elasticsearch/reference/6.5/setting-system-settings.html</a></p>
<h2 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a><strong>mmap</strong></h2><p>Elasticsearch 对各种文件混合使用了 NioFs（ 注：非阻塞文件系统）和 MMapFs （ 注：内存映射文件系统）。请确保你配置的最大映射数量，以便有足够的虚拟内存可用于 mmapped 文件。这可以暂时设置：sysctl -w vm.max_map_count&#x3D;262144或者你可以在 &#x2F;etc&#x2F;sysctl.conf 通过修改 vm.max_map_count 永久设置它。</p>
<p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/_file_descriptors_and_mmap.html">https://www.elastic.co/guide/cn/elasticsearch/guide/current/_file_descriptors_and_mmap.html</a></p>
<h2 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a><strong>磁盘</strong></h2><p>如果你正在使用 SSDs，确保你的系统 I&#x2F;O 调度程序是配置正确的。 当你向硬盘写数据，I&#x2F;O 调度程序决定何时把数据实际发送到硬盘。 大多数默认 <em>nix 发行版下的调度程序都叫做</em> <em>cfq**（完全公平队列）。但它是为旋转介质优化的： 机械硬盘的固有特性意味着它写入数据到基于物理布局的硬盘会更高效。这对 SSD 来说是低效的，尽管这里没有涉及到机械硬盘。但是，deadline 或者 noop 应该被使用。deadline 调度程序基于写入等待时间进行优化， noop 只是一个简单的 FIFO 队列。echo noop &gt; &#x2F;sys&#x2F;block&#x2F;sd</em>&#x2F;queue&#x2F;scheduler</p>
<h3 id="磁盘挂载"><a href="#磁盘挂载" class="headerlink" title="磁盘挂载"></a><strong>磁盘挂载</strong></h3><p>mount -o noatime,data&#x3D;writeback,barrier&#x3D;0,nobh &#x2F;dev&#x2F;sd* &#x2F;esdata*其中，noatime，禁止记录访问时间戳；data&#x3D;writeback，不记录journal；barrier&#x3D;0，因为关闭了journal，所以同步关闭barrier；nobh，关闭buffer_head，防止内核影响数据IO</p>
<h3 id="磁盘其他注意事项"><a href="#磁盘其他注意事项" class="headerlink" title="磁盘其他注意事项"></a><strong>磁盘其他注意事项</strong></h3><p>使用 RAID 0。条带化 RAID 会提高磁盘I&#x2F;O，代价显然就是当一块硬盘故障时整个就故障了，不要使用镜像或者奇偶校验 RAID 因为副本已经提供了这个功能。另外，使用多块硬盘，并允许 Elasticsearch 通过多个 path.data 目录配置把数据条带化分配到它们上面。不要使用远程挂载的存储，比如 NFS 或者 SMB&#x2F;CIFS。这个引入的延迟对性能来说完全是背道而驰的。</p>
<h1 id="三、elasticsearch使用方式调优"><a href="#三、elasticsearch使用方式调优" class="headerlink" title="三、elasticsearch使用方式调优"></a>三、elasticsearch使用方式调优</h1><p>当elasticsearch本身的配置没有明显的问题之后，发现es使用还是非常慢，这个时候，就需要我们去定位es本身的问题了，首先祭出定位问题的第一个命令：</p>
<h2 id="hot-threads"><a href="#hot-threads" class="headerlink" title="hot_threads"></a><strong>hot_threads</strong></h2><p>GET &#x2F;_nodes&#x2F;hot_threads&amp;interval&#x3D;30s</p>
<p>抓取30s的节点上占用资源的热线程，并通过排查占用资源最多的TOP线程来判断对应的资源消耗是否正常，一般情况下，bulk，search类的线程占用资源都可能是业务造成的，但是如果是merge线程占用了大量的资源，就应该考虑是不是创建index或者刷磁盘间隔太小，批量写入size太小造成的。</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.x/cluster-nodes-hot-threads.html">https://www.elastic.co/guide/en/elasticsearch/reference/6.x/cluster-nodes-hot-threads.html</a></p>
<h2 id="pending-tasks"><a href="#pending-tasks" class="headerlink" title="pending_tasks"></a><strong>pending_tasks</strong></h2><p>GET &#x2F;_cluster&#x2F;pending_tasks</p>
<p>有一些任务只能由主节点去处理，比如创建一个新的 索引或者在集群中移动分片，由于一个集群中只能有一个主节点，所以只有这一master节点可以处理集群级别的元数据变动。在99.9999%的时间里，这不会有什么问题，元数据变动的队列基本上保持为零。在一些罕见的集群里，元数据变动的次数比主节点能处理的还快，这会导致等待中的操作会累积成队列。这个时候可以通过pending_tasks api分析当前什么操作阻塞了es的队列，比如，集群异常时，会有大量的shard在recovery，如果集群在大量创建新字段，会出现大量的put_mappings的操作，所以正常情况下，需要禁用动态mapping。</p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-pending.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-pending.html</a></p>
<h2 id="字段存储"><a href="#字段存储" class="headerlink" title="字段存储"></a><strong>字段存储</strong></h2><p>当前es主要有doc_values，fielddata，storefield三种类型，大部分情况下，并不需要三种类型都存储，可根据实际场景进行调整：当前用得最多的就是doc_values，列存储，对于不需要进行分词的字段，都可以开启doc_values来进行存储（且只保留keyword字段），节约内存，当然，开启doc_values会对查询性能有一定的影响，但是，这个性能损耗是比较小的，而且是值得的；</p>
<p>fielddata构建和管理 100% 在内存中，常驻于 JVM 内存堆，所以可用于快速查询，但是这也意味着它本质上是不可扩展的，有很多边缘情况下要提防，如果对于字段没有分析需求，可以关闭fielddata；</p>
<p>storefield主要用于_source字段，默认情况下，数据在写入es的时候，es会将doc数据存储为_source字段，查询时可以通过_source字段快速获取doc的原始结构，如果没有update，reindex等需求，可以将_source字段disable；</p>
<p>_all，ES在6.x以前的版本，默认将写入的字段拼接成一个大的字符串，并对该字段进行分词，用于支持整个doc的全文检索，在知道doc字段名称的情况下，建议关闭掉该字段，节约存储空间，也避免不带字段key的全文检索；</p>
<p>norms：搜索时进行评分，日志场景一般不需要评分，建议关闭；</p>
<h2 id="tranlog"><a href="#tranlog" class="headerlink" title="tranlog"></a><strong>tranlog</strong></h2><p>Elasticsearch 2.0之后为了保证不丢数据，每次 index、bulk、delete、update 完成的时候，一定触发刷新 translog 到磁盘上，才给请求返回 200 OK。这个改变在提高数据安全性的同时当然也降低了一点性能。如果你不在意这点可能性，还是希望性能优先，可以在 index template 里设置如下参数：</p>
<p>{    “index.translog.durability”: “async”}</p>
<p>index.translog.sync_interval：对于一些大容量的偶尔丢失几秒数据问题也并不严重的集群，使用异步的 fsync 还是比较有益的。比如，写入的数据被缓存到内存中，再每5秒执行一次 fsync ，默认为5s。小于的值100ms是不允许的。index.translog.flush_threshold_size：translog存储尚未安全保存在Lucene中的所有操作。虽然这些操作可用于读取，但如果要关闭并且必须恢复，则需要重新编制索引。此设置控制这些操作的最大总大小，以防止恢复时间过长。达到设置的最大size后，将发生刷新，生成新的Lucene提交点，默认为512mb。</p>
<h2 id="refresh-interval"><a href="#refresh-interval" class="headerlink" title="refresh_interval"></a><strong>refresh_interval</strong></h2><p>执行刷新操作的频率，这会使索引的最近更改对搜索可见，默认为1s，可以设置-1为禁用刷新，对于写入速率要求较高的场景，可以适当的加大对应的时长，减小磁盘io和segment的生成；</p>
<h2 id="禁止动态mapping"><a href="#禁止动态mapping" class="headerlink" title="禁止动态mapping"></a><strong>禁止动态mapping</strong></h2><p>动态mapping的坏处：1.造成集群元数据一直变更，导致集群不稳定；2.可能造成数据类型与实际类型不一致；3.对于一些异常字段或者是扫描类的字段，也会频繁的修改mapping，导致业务不可控。动态mapping配置的可选值及含义如下：true：支持动态扩展，新增数据有新的字段属性时，自动添加对于的mapping，数据写入成功false：不支持动态扩展，新增数据有新的字段属性时，直接忽略，数据写入成功strict：不支持动态扩展，新增数据有新的字段时，报错，数据写入失败</p>
<h2 id="批量写入"><a href="#批量写入" class="headerlink" title="批量写入"></a><strong>批量写入</strong></h2><p>批量请求显然会大大提升写入速率，且这个速率是可以量化的，官方建议每次批量的数据物理字节数5-15MB是一个比较不错的起点，注意这里说的是物理字节数大小。文档计数对批量大小来说不是一个好指标。比如说，如果你每次批量索引 1000 个文档，记住下面的事实：1000 个 1 KB 大小的文档加起来是 1 MB 大。1000 个 100 KB 大小的文档加起来是 100 MB 大。这可是完完全全不一样的批量大小了。批量请求需要在协调节点上加载进内存，所以批量请求的物理大小比文档计数重要得多。从 5–15 MB 开始测试批量请求大小，缓慢增加这个数字，直到你看不到性能提升为止。然后开始增加你的批量写入的并发度（多线程等等办法）。用iostat 、 top 和 ps 等工具监控你的节点，观察资源什么时候达到瓶颈。如果你开始收到 EsRejectedExecutionException ，你的集群没办法再继续了：至少有一种资源到瓶颈了。或者减少并发数，或者提供更多的受限资源（比如从机械磁盘换成 SSD），或者添加更多节点。</p>
<h2 id="索引和shard"><a href="#索引和shard" class="headerlink" title="索引和shard"></a><strong>索引和shard</strong></h2><p>es的索引，shard都会有对应的元数据，且因为es的元数据都是保存在master节点，且元数据的更新是要hang住集群向所有节点同步的，当es的新建字段或者新建索引的时候，都会要获取集群元数据，并对元数据进行变更及同步，此时会影响集群的响应，所以需要关注集群的index和shard数量，建议如下：1.使用shrink和rollover api，相对生成合适的数据shard数；2.根据数据量级及对应的性能需求，选择创建index的名称，形如：按月生成索引：test-YYYYMM，按天生成索引：test-YYYYMMDD；3.控制单个shard的size，正常情况下，日志场景，建议单个shard不大于50GB，线上业务场景，建议单个shard不超过20GB；</p>
<h2 id="segment-merge"><a href="#segment-merge" class="headerlink" title="segment merge"></a><strong>segment merge</strong></h2><p>段合并的计算量庞大， 而且还要吃掉大量磁盘 I&#x2F;O。合并在后台定期操作，因为他们可能要很长时间才能完成，尤其是比较大的段。这个通常来说都没问题，因为大规模段合并的概率是很小的。如果发现merge占用了大量的资源，可以设置：index.merge.scheduler.max_thread_count: 1特别是机械磁盘在并发 I&#x2F;O 支持方面比较差，所以我们需要降低每个索引并发访问磁盘的线程数。这个设置允许 max_thread_count + 2 个线程同时进行磁盘操作，也就是设置为 1 允许三个线程。对于 SSD，你可以忽略这个设置，默认是 Math.min(3, Runtime.getRuntime().availableProcessors() &#x2F; 2) ，对 SSD 来说运行的很好。业务低峰期通过force_merge强制合并segment，降低segment的数量，减小内存消耗；关闭冷索引，业务需要的时候再进行开启，如果一直不使用的索引，可以定期删除，或者备份到hadoop集群；</p>
<h2 id="自动生成-id"><a href="#自动生成-id" class="headerlink" title="自动生成_id"></a><strong>自动生成_id</strong></h2><p>当写入端使用特定的id将数据写入es时，es会去检查对应的index下是否存在相同的id，这个操作会随着文档数量的增加而消耗越来越大，所以如果业务上没有强需求，建议使用es自动生成的id，加快写入速率。</p>
<h2 id="routing"><a href="#routing" class="headerlink" title="routing"></a><strong>routing</strong></h2><p>对于数据量较大的业务查询场景，es侧一般会创建多个shard，并将shard分配到集群中的多个实例来分摊压力，正常情况下，一个查询会遍历查询所有的shard，然后将查询到的结果进行merge之后，再返回给查询端。此时，写入的时候设置routing，可以避免每次查询都遍历全量shard，而是查询的时候也指定对应的routingkey，这种情况下，es会只去查询对应的shard，可以大幅度降低合并数据和调度全量shard的开销。</p>
<h2 id="使用alias"><a href="#使用alias" class="headerlink" title="使用alias"></a><strong>使用alias</strong></h2><p>生产提供服务的索引，切记使用别名提供服务，而不是直接暴露索引名称，避免后续因为业务变更或者索引数据需要reindex等情况造成业务中断。</p>
<h2 id="避免宽表"><a href="#避免宽表" class="headerlink" title="避免宽表"></a><strong>避免宽表</strong></h2><p>在索引中定义太多字段是一种可能导致映射爆炸的情况，这可能导致内存不足错误和难以恢复的情况，这个问题可能比预期更常见，index.mapping.total_fields.limit ，默认值是1000</p>
<h2 id="避免稀疏索引"><a href="#避免稀疏索引" class="headerlink" title="避免稀疏索引"></a><strong>避免稀疏索引</strong></h2><p>因为索引稀疏之后，对应的相邻文档id的delta值会很大，lucene基于文档id做delta编码压缩导致压缩率降低，从而导致索引文件增大，同时，es的keyword，数组类型采用doc_values结构，每个文档都会占用一定的空间，即使字段是空值，所以稀疏索引会造成磁盘size增大，导致查询和写入效率降低。</p>
]]></content>
      <categories>
        <category>elk</category>
        <category>es</category>
      </categories>
      <tags>
        <tag>es</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>es系统初始化</title>
    <url>/posts/8d93/</url>
    <content><![CDATA[<p><strong>1、vim &#x2F;etc&#x2F;security&#x2F;limits.conf</strong></p>
<pre class="line-numbers language-none"><code class="language-none">*   soft    nofile     65536
*   hard   nofile     65536<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<p><strong>#number of threads</strong></p>
<pre class="line-numbers language-none"><code class="language-none">*   soft     nproc     64000
*   hard    nproc    64000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<p>vim &#x2F;etc&#x2F;security&#x2F;limits.d&#x2F;20-nproc.conf</p>
<p>(处理max number of threads [3885] for user [elk] is too low, increase to at least [4096])</p>
<pre class="line-numbers language-none"><code class="language-none">*     soft  nproc   10240
*     hard  nproc   10240<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<p><strong>2、关闭交换分区</strong></p>
<p>swapoff -a</p>
<p>注释掉&#x2F;etc&#x2F;fstab中有swap的一行，</p>
<p>或者在&#x2F;etc&#x2F;sysctl.conf中添加 vm.swappiness&#x3D;1。</p>
<p><strong>3、Enable bootstrap.memory_lock</strong></p>
<p>vim $ES_HOME&#x2F;config&#x2F;elasticsearch.yml</p>
<pre class="line-numbers language-none"><code class="language-none">bootstrap.memory_lock: true<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<p><strong>添加&#x2F;etc&#x2F;security&#x2F;limits.conf</strong></p>
<pre class="line-numbers language-none"><code class="language-none">* hard memlock unlimited * soft memlock unlimited<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<p><strong>vim &#x2F;etc&#x2F;systemd&#x2F;system.conf</strong></p>
<pre class="line-numbers language-none"><code class="language-none">DefaultLimitNOFILE&#x3D;65536 DefaultLimitNPROC&#x3D;32000 DefaultLimitMEMLOCK&#x3D;infinity

&#x2F;bin&#x2F;systemctl daemon-reload<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<p>4、虚拟内存的配置</p>
<pre class="line-numbers language-none"><code class="language-none">sysctl -w vm.max_map_count&#x3D;262144<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<p>并在&#x2F;etc&#x2F;sysctl.conf中添加</p>
<pre class="line-numbers language-none"><code class="language-none">echo  &quot;vm.max_map_count&#x3D;262144&quot;&gt;&gt;&#x2F;etc&#x2F;sysctl.conf<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<p>sysctl -p</p>
<p><strong>常见报错：</strong></p>
<p>ERROR: [2] bootstrap checks failed</p>
<p>[1]: max file descriptors [65535] for elasticsearch process is too low, increase to at least [65536]</p>
<p>[2]: memory locking requested for elasticsearch process but memory is not locked</p>
<p> vim &#x2F;etc&#x2F;security&#x2F;limits.conf</p>
<pre class="line-numbers language-none"><code class="language-none">*   soft    nofile     65536
*   hard   nofile     65536<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<p>vim &#x2F;etc&#x2F;security&#x2F;limits.conf</p>
<pre class="line-numbers language-none"><code class="language-none">* soft memlock unlimited
* hard memlock unlimited<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<p><strong>elastic 系统初始化脚本</strong></p>
<pre class="line-numbers language-none"><code class="language-none">#!&#x2F;bin&#x2F;bash
#elasticsearch安装系统配置初始化脚本
esuser&#x3D;elasitc
create_user() &#123;
if ! grep &quot;^$esuser:&quot; &#x2F;etc&#x2F;passwd ; then
	useradd $esuser
	echo &quot;$esuser&quot; | passwd &quot;$esuser&quot; --stdin &amp;&gt;&#x2F;dev&#x2F;null
	check_ok
else
	echo $esuser already exist!
fi
&#125;


set_system() &#123;
cat &gt;&gt; &#x2F;etc&#x2F;security&#x2F;limits.conf &lt;&lt; EOF
#max open files
*   soft    nofile     65536
*   hard    nofile     65536
#number of threads	
*   soft    nproc    64000
*   hard    nproc    64000
*   soft    memlock unlimited
*   hard    memlock unlimited
EOF

# 配置最大虚拟内存
cat &gt;&gt; &#x2F;etc&#x2F;sysctl.conf &lt;&lt; EOF
vm.max_map_count&#x3D;262144
EOF
# 生效
sysctl -p


cat &gt;&gt; &#x2F;etc&#x2F;systemd&#x2F;system.conf &lt;&lt; EOF
DefaultLimitNOFILE&#x3D;65536
DefaultLimitNPROC&#x3D;32000
DefaultLimitMEMLOCK&#x3D;infinity
EOF
&#x2F;bin&#x2F;systemctl daemon-reload

#关闭swap
swapoff -a
sed -i &#39;s&#x2F;^[^#].*swap&#x2F;#&amp;&#x2F;&#39; &#x2F;etc&#x2F;fstab

&#125;


create_user
set_system
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

]]></content>
      <categories>
        <category>elk</category>
        <category>es</category>
      </categories>
      <tags>
        <tag>es</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>ES配置Monitoring监控日志</title>
    <url>/posts/8ce5/</url>
    <content><![CDATA[<p>通过配置Monitoring监控日志<br>您可以查看阿里云Elasticsearch（简称ES）实例的监控日志并配置监控索引，避免因监控日志占用空间过大而影响实例的正常使用。</p>
<h2 id="背景信息"><a href="#背景信息" class="headerlink" title="背景信息"></a>背景信息</h2><p>默认情况下，X-Pack监控客户端会每隔10s采集一次集群的监控信息，并保存到对应阿里云ES实例的以.monitoring-*为前缀的索引中。<br>目前主要有.monitoring-es-6-*和.monitoring-kibana-6-*这两种索引，以天为单位滚动创建。采集完的信息会保存在以.monitoring-es-6-为前缀，以当前日期为后缀的索引中。<br>其中.monitoring-es-6-*索引占用磁盘空间较大，主要存放了集群状态、集群统计、节点统计、索引统计等信息。</p>
<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>系统默认保留最近7天的监控索引，此类监控索引（.monitoring-es-6-*）会占用阿里云ES实例的存储空间。索引的大小与实例中的索引个数（包含系统索引）和节点个数有关系。为了避免实例的大部分空间被监控索引占用，可通过以下两种方式进行优化（实际使用中，可以将以上两种方案结合使用）</p>
<ul>
<li><p>设置监控索引的保留天数。可以按照需求自定义监控索引的保留天数，最少保留一天。</p>
<pre class="line-numbers language-none"><code class="language-none">PUT _cluster&#x2F;settings
&#123;&quot;persistent&quot;: &#123;&quot;xpack.monitoring.history.duration&quot;:&quot;1d&quot;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

</li>
<li><p>设置需要采集的监控索引。<br>通过调用API设置哪些索引需要监控以及哪些索引不需要监控，以减少.monitoring-es-6-*索引所占用的磁盘空间。以下命令以禁掉采集系统索引为例。</p>
<pre class="line-numbers language-none"><code class="language-none">PUT _cluster&#x2F;settings
&#123;&quot;persistent&quot;: &#123;&quot;xpack.monitoring.collection.indices&quot;: &quot;*,-.*&quot;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li>
</ul>
<p>说明 禁掉的索引监控信息将不会在Kibana控制台的Montioring页面（索引列表及索引监控信息页面）中显示。但是会在GET _cat&#x2F;indices获取的索引列表中显示，并且可查看索引的状态是open还是close。</p>
]]></content>
      <categories>
        <category>elk</category>
        <category>logstash</category>
      </categories>
      <tags>
        <tag>es</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>es常见问题汇总</title>
    <url>/posts/84e2/</url>
    <content><![CDATA[<h2 id="ES-failed-shard-on-node-XXX-failed-recovery-failure-RecoveryFailedException"><a href="#ES-failed-shard-on-node-XXX-failed-recovery-failure-RecoveryFailedException" class="headerlink" title="ES failed shard on node[XXX]: failed recovery, failure RecoveryFailedException"></a>ES failed shard on node[XXX]: failed recovery, failure RecoveryFailedException</h2><pre class="line-numbers language-none"><code class="language-none">原因是：某节点上的分片尝试恢复5次没有成功，然后就丢弃不管。导致该分片无法恢复。

解决办法：重新恢复失败的分片，一会集群就恢复为green
POST &#x2F;_cluster&#x2F;reroute?retry_failed&#x3D;true
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="es-剩余磁盘空间达到es最小值，添加数据被block"><a href="#es-剩余磁盘空间达到es最小值，添加数据被block" class="headerlink" title="es 剩余磁盘空间达到es最小值，添加数据被block"></a>es 剩余磁盘空间达到es最小值，添加数据被block</h2><pre class="line-numbers language-none"><code class="language-none">
剩余磁盘空间达到es最小值，添加数据被block

查看集群索引是否依然为read_only状态，如果是请执行以下命令，将集群中所有索引的index.blocks.read_only_allow_delete属性设置为null，使集群中不再存在read_only状态的索引。

PUT _all&#x2F;_settings
&#123;&quot;index.blocks.read_only_allow_delete&quot;: null&#125;

删除单个index全部内容，或删除无用的索引
DELETE &#x2F;new_listings_investment
&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125; &#125;

若集群是否依然为Red状态，执行以下命令，查看集群中是否存在未分配的分片。
_cat&#x2F;allocation?v

如果存在未分配的分片，执行以下命令，查看未分配分片的原因。
GET _cluster&#x2F;allocation&#x2F;explain

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-none"><code class="language-none">如果使用 ES 的默认设置，ES 为了保持节点可用，设置了几个存储的安全值。分别为：

cluster.routing.allocation.disk.watermark.low: 默认 85% 当达到时，replica 不再写入 .导致新的分片无法分配。
cluster.routing.allocation.disk.watermark.high: 默认 90%. 当达到时Elasticsearch会尝试将对应节点中的分片迁移到其他磁盘使用率比较低的数据节点中
cluster.routing.allocation.disk.watermark.flood_stage: 默认 95% 系统会对Elasticsearch集群中的每个索引强制设置read_only_allow_delete属性，此时索引将无法写入数据，只能读取和删除对应索引<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>elk</category>
        <category>es</category>
      </categories>
      <tags>
        <tag>es</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>es-api</title>
    <url>/posts/62b1/</url>
    <content><![CDATA[<hr>
<h1 id="cat-api"><a href="#cat-api" class="headerlink" title="_cat api"></a>_cat api</h1><p>通过 GET 请求发送 cat 命名可以列出所有可用的 API：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">GET /_cat

<span class="token operator">=</span>^.^<span class="token operator">=</span>
/_cat/allocation    查看资源分配情况
/_cat/shards        查所有分片信息
/_cat/shards/<span class="token punctuation">&#123;</span>index<span class="token punctuation">&#125;</span>查看某个索引分片信息
/_cat/master        查看master节点
/_cat/nodes         查看节点信息
/_cat/tasks
/_cat/indices       查看所有索引信息
/_cat/indices/<span class="token punctuation">&#123;</span>index<span class="token punctuation">&#125;</span>查看某个索引信息
/_cat/segments      显示碎片中的分段信息
/_cat/segments/<span class="token punctuation">&#123;</span>index<span class="token punctuation">&#125;</span>显示某个索引中碎片中的分段信息
/_cat/count     显示索引文档数量
/_cat/count/<span class="token punctuation">&#123;</span>index<span class="token punctuation">&#125;</span>显示某个索引文档数量
/_cat/recovery  显示正在进行和先前完成的索引碎片恢复的视图
/_cat/recovery/<span class="token punctuation">&#123;</span>index<span class="token punctuation">&#125;</span>显示某个索引正在进行和先前完成的索引碎片恢复的视图
/_cat/health    查看集群健康状况
/_cat/pending_tasks显示正在等待的任务
/_cat/aliases   显示别名、过滤器、路由信息
/_cat/aliases/<span class="token punctuation">&#123;</span>alias<span class="token punctuation">&#125;</span>显示具体别名、过滤器、路由信息
/_cat/thread_pool   查看线程、队列等使用情况
/_cat/thread_pool/<span class="token punctuation">&#123;</span>thread_pools<span class="token punctuation">&#125;</span>
/_cat/plugins       显示每个运行插件节点的视图
/_cat/fielddata     查看当前集群各个节点的fielddata内存使用情况
/_cat/fielddata/<span class="token punctuation">&#123;</span>fields<span class="token punctuation">&#125;</span>查看指定field的内存使用情况,里面传field属性对应的值
/_cat/nodeattrs     显示node节点属性
/_cat/repositories  查看存储库？
/_cat/snapshots/<span class="token punctuation">&#123;</span>repository<span class="token punctuation">&#125;</span> 查看存储库的快照？
/_cat/templates     查看模板信息
/_cluster/settings  查看集群设置
/_cluster/settings?include_defaults<span class="token operator">=</span>true  查看集群设置（包括默认设置）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>对任意 API 添加 ?help 参数</p>
<pre class="line-numbers language-none"><code class="language-none">GET &#x2F;_cat&#x2F;nodes?help

id               | id,nodeId               | unique node id
pid              | p                       | process id
host             | h                       | host name
ip               | i                       | ip address
port             | po                      | bound transport port
version          | v                       | es version
build            | b                       | es build hash
jdk              | j                       | jdk version
disk.avail       | d,disk,diskAvail        | available disk space
heap.percent     | hp,heapPercent          | used heap ratio
heap.max         | hm,heapMax              | max configured heap
ram.percent      | rp,ramPercent           | used machine memory ratio
ram.max          | rm,ramMax               | total machine memory
load             | l                       | most recent load avg
uptime           | u                       | node uptime
node.role        | r,role,dc,nodeRole      | d:data node, c:client node
master           | m                       | m:master-eligible, *:current master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用 ?h 参数来明确指定显示这些指标：</p>
<pre class="line-numbers language-none"><code class="language-none">GET &#x2F;_cat&#x2F;nodes?v&amp;h&#x3D;ip,port,heapPercent,heapMax

ip            port heapPercent heapMax
192.168.1.131 9300          53 990.7mb<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>


<p>查看节点信息</p>
<p>GET &#x2F;_cat&#x2F;nodes?v</p>
<p>查看资源分配情况</p>
<p>GET &#x2F;_cat&#x2F;allocation?v</p>
<p>查看当前线程组状态</p>
<p>GET &#x2F;_nodes&#x2F;stats?pretty</p>
<p>查看线程、队列等使用情况</p>
<p>GET _cat&#x2F;thread_pool?v</p>
<p>查看集群设置</p>
<p>GET &#x2F;_cluster&#x2F;settings</p>
<p>查看所有设置</p>
<p>GET &#x2F;_all&#x2F;_settings</p>
<p>查看集群健康状态</p>
<p>GET &#x2F;_cluster&#x2F;health</p>
<p>查看License</p>
<pre class="line-numbers language-none"><code class="language-none">GET &#x2F;_license<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<p>查看集群状态</p>
<pre class="line-numbers language-none"><code class="language-none">GET &#x2F;_cluster&#x2F;state<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<p>查看ES连接数</p>
<pre class="line-numbers language-none"><code class="language-none">netstat -anp | grep ESTABLISHED | grep 9200 | gawk &#39;&#123;print $5&#125;&#39; | gawk -F&#39;:&#39; &#39;&#123;print $4&#125;&#39; | sort -rn | uniq -c | sort -rn<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>参数修改</p>
<p>设置延迟分配,修改分片延时</p>
<pre class="line-numbers language-none"><code class="language-none">PUT &#x2F;_all&#x2F;_settings
&#123;
  &quot;settings&quot;:&#123;
    &quot;index.unassigned.node_left.delayed_timeout&quot;:&quot;5m&quot;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>同步刷新</p>
<pre class="line-numbers language-none"><code class="language-none">POST _flush&#x2F;synced<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<p>自动均衡开关</p>
<pre class="line-numbers language-none"><code class="language-none">关闭
PUT &#x2F;_cluster&#x2F;settings
&#123;
    &quot;transient&quot; : &#123;
        &quot;cluster.routing.allocation.enable&quot; : &quot;none&quot;
    &#125;
&#125;
打开
PUT &#x2F;_cluster&#x2F;settings
&#123;
    &quot;transient&quot; : &#123;
        &quot;cluster.routing.allocation.enable&quot; : &quot;all&quot;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>修改集群自动发现</p>
<pre class="line-numbers language-none"><code class="language-none">PUT &#x2F;_cluster&#x2F;settings
&#123;
    &quot;transient&quot;: &#123;
        &quot;discovery.zen.minimum_master_nodes&quot; : 2
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>调整分片使其主分片和副分片分布在不同的主机上</p>
<pre class="line-numbers language-none"><code class="language-none">PUT &#x2F;_cluster&#x2F;settings
&#123;
 &quot;persistent&quot;: &#123;
        &quot;cluster.routing.allocation.same_shard.host&quot;: &quot;on&quot;
 &#125;
&#125;

PUT &#x2F;_cluster&#x2F;settings
&#123;
 &quot;transient&quot;: &#123;
        &quot;cluster.routing.allocation.same_shard.host&quot;: &quot;on&quot;
 &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>查看索引模板</p>
<pre class="line-numbers language-none"><code class="language-none">GET &#x2F;_template<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>查询具体某个模板</p>
<pre class="line-numbers language-none"><code class="language-none">GET &#x2F;_template&#x2F;test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<p>修改更新间隔</p>
<pre class="line-numbers language-none"><code class="language-none">PUT &#x2F;_template&#x2F;template_1
&#123;
    &quot;template&quot; : &quot;my-index*&quot;,
    &quot;order&quot; : 0,
    &quot;settings&quot; : &#123;
        &quot;index&quot;: &#123;
        &quot;refresh_interval&quot;: &quot;300s&quot;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>创建索引模板<br>PUT _template&#x2F;feature_template</p>
<pre class="line-numbers language-none"><code class="language-none">PUT _template&#x2F;template_1

&#123;
  &quot;index_patterns&quot;: &quot;test*&quot;,
  &quot;settings&quot;: &#123;
    &quot;number_of_replicas&quot;: 0,
    &quot;refresh_interval&quot;: &quot;30s&quot;
  &#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>删除索引模板</p>
<pre class="line-numbers language-none"><code class="language-none">DELETE &#x2F;_template&#x2F;template_1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<p>查看修改单个索引刷新间隔</p>
<pre class="line-numbers language-none"><code class="language-none">GET &#x2F;my-index&#x2F;_settings
&#x2F;_settings

PUT &#x2F;my-index_2018-06-15&#x2F;_settings
&#123;
  &quot;settings&quot;: &#123;
     &quot;index&quot;: &#123;
        &quot;refresh_interval&quot;: &quot;60s&quot;
      &#125;
   &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>查看所有node：</p>
<pre class="line-numbers language-none"><code class="language-none">GET &#x2F;_cat&#x2F;nodes?v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<p>查看所有索引：</p>
<pre class="line-numbers language-none"><code class="language-none">GET &#x2F;_cat&#x2F;indices?v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<p>修改索引副本数量为0</p>
<pre class="line-numbers language-none"><code class="language-none">PUT &#x2F;my-index&#x2F;_settings
&#123;
  &quot;index&quot;: &#123;
        &quot;number_of_replicas&quot;: &quot;1&quot;
        &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<p>各个分片、索引的fielddata在内存中的占用情况</p>
<pre class="line-numbers language-none"><code class="language-none">GET &#x2F;_stats&#x2F;fielddata?fields&#x3D;*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<p>每个node的fielddata在内存中的占用情况</p>
<pre class="line-numbers language-none"><code class="language-none">GET &#x2F;_nodes&#x2F;stats&#x2F;indices&#x2F;fielddata?fields&#x3D;*<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>


<p>每个node中的每个索引的fielddata在内存中的占用情况</p>
<pre class="line-numbers language-none"><code class="language-none">GET &#x2F;_nodes&#x2F;stats&#x2F;indices&#x2F;fielddata?level&#x3D;indices&amp;fields&#x3D;*
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>剩余磁盘空间达到es最小值，添加数据被block</p>
<pre class="line-numbers language-none"><code class="language-none">PUT _all&#x2F;_settings
&#123;&quot;index.blocks.read_only_allow_delete&quot;: null&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>es出现cluster_block_exception报错及解决</p>
<pre class="line-numbers language-none"><code class="language-none">curl -XPUT -H &quot;Content-Type: application&#x2F;json&quot; http:&#x2F;&#x2F;es-url:9200&#x2F;_all&#x2F;_settings -d &#39;&#123;&quot;index.blocks.read_only_allow_delete&quot;: null&#125;&#39;

PUT _cluster&#x2F;settings
&#123;
&quot;index.blocks.read_only_allow_delete&quot;: null
&#125;


cluster.routing.allocation.disk.watermark.low: 默认 85% 当达到时，replica 不再写入
cluster.routing.allocation.disk.watermark.high: 默认 90% 当达到时，shards 会尝试写入其他节点
cluster.routing.allocation.disk.watermark.flood_stage: 默认 95% 当达到时，所有索引变为 readonly状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<table>
<thead>
<tr>
<th>header 1</th>
<th>header 2</th>
</tr>
</thead>
<tbody><tr>
<td>row 1 col 1</td>
<td>row 1 col 2</td>
</tr>
<tr>
<td>row 2 col 1</td>
<td>row 2 col 2</td>
</tr>
</tbody></table>
<h1 id="运维命令概览"><a href="#运维命令概览" class="headerlink" title="运维命令概览"></a>运维命令概览</h1><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>GET &#x2F;_cat&#x2F;health?v</td>
<td>查看集群的健康状态。集群状态包括green、red、yellow，各状态的具体说明请参见查看集群健康状态。</td>
</tr>
<tr>
<td>GET &#x2F;_cluster&#x2F;health?pretty&#x3D;true</td>
<td>查看集群的健康状态。pretty&#x3D;true表示格式化输出。您也可以添加其他查询参数，例如：</td>
</tr>
<tr>
<td>level&#x3D;indices：</td>
<td>显示索引状态。</td>
</tr>
<tr>
<td>level&#x3D;shards：</td>
<td>显示分片信息。</td>
</tr>
<tr>
<td>GET &#x2F;_cluster&#x2F;stats</td>
<td>查看集群的系统信息。包括CPU、JVM等信息。</td>
</tr>
<tr>
<td>GET &#x2F;_cluster&#x2F;state</td>
<td>查看集群的详细信息。包括节点、分片等信息。</td>
</tr>
<tr>
<td>GET &#x2F;_cluster&#x2F;pending_tasks</td>
<td>查看集群中堆积的任务。</td>
</tr>
<tr>
<td>GET &#x2F;_cluster&#x2F;settings</td>
<td>查看集群设置。</td>
</tr>
<tr>
<td>POST _cache&#x2F;clear</td>
<td>缓存清理</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>调整索引监控日志保留时间（.monitoring-es-6-*）</p>
<pre class="line-numbers language-none"><code class="language-none">PUT _cluster&#x2F;settings &#123;&quot;persistent&quot;: &#123;&quot;xpack.monitoring.history.duration&quot;:&quot;0d&quot;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>



<p>设置需要采集的监控索引</p>
<pre class="line-numbers language-none"><code class="language-none">PUT _cluster&#x2F;settings &#123;&quot;persistent&quot;: &#123;&quot;xpack.monitoring.collection.indices&quot;:  &quot;*,-.*&quot; &#125; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>





<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>GET &#x2F;_cat&#x2F;master?v</td>
<td>查看集群中Master节点的信息。</td>
</tr>
<tr>
<td>GET &#x2F;_cat&#x2F;nodes?v</td>
<td>查看集群中各个节点的当前状态。包括节点CPU使用率、HeapMemory使用率、负载情况等。</td>
</tr>
<tr>
<td>GET &#x2F;_cat&#x2F;nodeattrs?v</td>
<td>查看单节点的自定义属性。</td>
</tr>
<tr>
<td>GET &#x2F;_nodes&#x2F;stats?pretty&#x3D;true</td>
<td>查看节点状态。</td>
</tr>
<tr>
<td>GET &#x2F;_nodes&#x2F;process</td>
<td>查看节点的进程信息。</td>
</tr>
<tr>
<td>GET &#x2F;_nodes&#x2F;hot_threads</td>
<td>查看高消耗的线程所执行的任务。</td>
</tr>
<tr>
<td>GET &#x2F;_nodes&#x2F;<nodeip>&#x2F;jvm,process,os</nodeip></td>
<td>查看指定节点的JVM、进程和操作系统信息。</td>
</tr>
<tr>
<td>GET _cat&#x2F;plugins?v</td>
<td>查看各节点的插件信息。</td>
</tr>
<tr>
<td>GET &#x2F;_cat&#x2F;thread_pool?v</td>
<td>查看各节点的线程池统计信息。包括线程池的类型、活跃线程数、任务队列大小等。</td>
</tr>
</tbody></table>
<h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>GET _cat&#x2F;indices</td>
<td>列出所有索引</td>
<td></td>
</tr>
<tr>
<td>POST &#x2F;my_index&#x2F;_open</td>
<td>打开索引</td>
<td></td>
</tr>
<tr>
<td>POST &#x2F;my_index&#x2F;_close</td>
<td>关闭索引</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>创建新的索引（Index）并设置分片数</p>
<pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token constant">PUT</span> <span class="token operator">/</span><span class="token operator">&lt;</span>indexName<span class="token operator">></span>
<span class="token punctuation">&#123;</span>
  <span class="token string-property property">"settings"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
    <span class="token string-property property">"index"</span><span class="token operator">:</span> <span class="token punctuation">&#123;</span>
      <span class="token string-property property">"number_of_shards"</span><span class="token operator">:</span> <span class="token number">5</span><span class="token punctuation">,</span>
      <span class="token string-property property">"number_of_replicas"</span><span class="token operator">:</span> <span class="token number">1</span>
    <span class="token punctuation">&#125;</span>
  <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>设置索引index慢日志</p>
<pre class="line-numbers language-none"><code class="language-none">PUT &#x2F;my_index&#x2F;_settings
&#123;
    &quot;index.search.slowlog.threshold.query.warn&quot; : &quot;10s&quot;,
    &quot;index.search.slowlog.threshold.fetch.debug&quot;: &quot;500ms&quot;,
    &quot;index.indexing.slowlog.threshold.index.info&quot;: &quot;5s&quot;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>设置所有的索引的index慢日志时间</p>
<pre class="line-numbers language-none"><code class="language-none">PUT  _settings
&#123;
        &quot;index.indexing.slowlog.threshold.index.debug&quot; : &quot;0ms&quot;,
        &quot;index.indexing.slowlog.threshold.index.info&quot; : &quot;0ms&quot;,
        &quot;index.indexing.slowlog.threshold.index.trace&quot; : &quot;0ms&quot;,
        &quot;index.indexing.slowlog.threshold.index.warn&quot; : &quot;0ms&quot;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>设置慢查询fetch</p>
<pre class="line-numbers language-none"><code class="language-none">PUT _settings
&#123;
    &quot;index.search.slowlog.threshold.fetch.warn&quot;:&quot;1s&quot;,
    &quot;index.search.slowlog.threshold.fetch.info&quot;:&quot;800ms&quot;,
    &quot;index.search.slowlog.threshold.fetch.debug&quot;:&quot;500ms&quot;,
    &quot;index.search.slowlog.threshold.fetch.trace&quot;:&quot;200ms&quot;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>设置慢查询query</p>
<pre class="line-numbers language-none"><code class="language-none">PUT _settings
&#123;
     &quot;index.search.slowlog.threshold.query.warn&quot;:&quot;5s&quot;,
    &quot;index.search.slowlog.threshold.query.info&quot;:&quot;2s&quot;,
    &quot;index.search.slowlog.threshold.query.debug&quot;:&quot;1s&quot;,
    &quot;index.search.slowlog.threshold.query.trace&quot;:&quot;400ms&quot;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><table>
<thead>
<tr>
<th align="left">命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">GET &#x2F;_cat&#x2F;shards?v</td>
<td>查看集群中各分片的详细情况。包括索引名称、分片编号、是主分片还是副分片、分片的当前状态（对于分配失败的分片会有失败原因）、doc数量、磁盘占用情况等。您也可以指定index，查看该index的分片信息（GET _cat&#x2F;shards&#x2F;<index>?v）。</index></td>
</tr>
<tr>
<td align="left">GET &#x2F;_cat&#x2F;allocation?v</td>
<td>查看集群中每个节点的分片分配情况。</td>
</tr>
<tr>
<td align="left">GET &#x2F;_cat&#x2F;recovery?v</td>
<td>查看集群中每个分片的恢复过程。</td>
</tr>
</tbody></table>
<p>设置my-index的分片副本数为2</p>
<pre class="line-numbers language-none"><code class="language-none">curl -XPUT &#39;http:&#x2F;&#x2F;localhost:9200&#x2F;my-index&#x2F;_settings&#39; -d &#39;&#123;

   &quot;number_of_replicas&quot; : 2

&#125;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<pre class="line-numbers language-none"><code class="language-none">PUT &#x2F;my-index*&#x2F;_settings
&#123;
  &quot;index&quot;: &#123;
        &quot;number_of_replicas&quot;: &quot;0&quot;
        &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>集群则会在一段时间内不做分配</p>
<p>在宕机节点重启后，由宕机节点本机磁盘数据进行恢复，在大型集群调优中，能提到数倍的恢复差异。</p>
<pre class="line-numbers language-none"><code class="language-none">PUT &#x2F;all&#x2F;settings
&#123;
  &quot;settings&quot;: &#123;
    &quot;index.unassigned.node_left.delayed_timeout&quot;:&quot;5m&quot;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<p>设置集群所有的分片自动均衡</p>
<pre class="line-numbers language-none"><code class="language-none">PUT &#x2F;_cluster&#x2F;settings
&#123;
    &quot;transient&quot; : &#123;
        &quot;cluster.routing.allocation.enable&quot;:&quot;all&quot;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>设置my-index 分片不自动均衡</p>
<pre class="line-numbers language-none"><code class="language-none">curl -XPUT &#39;http:&#x2F;&#x2F;168.7.1.67:9200&#x2F;my-index&#x2F;_settings&#39; -d &#39;&#123;

   &quot;cluster.routing.allocation.disable_allocation&quot;:true

&#125;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>手动移动分片</p>
<pre class="line-numbers language-none"><code class="language-none">curl -XPOST &quot;http:&#x2F;&#x2F;168.7.1.67:9200&#x2F;_cluster&#x2F;reroute&#39; -d  &#39;&#123;
   &quot;commands&quot; : [&#123;
		&quot;move&quot; : &#123;
			&quot;index&quot; : &quot;my-index&quot;,
			&quot;shard&quot; : 0,
			&quot;from_node&quot; : &quot;es-0&quot;,
			&quot;to_node&quot; : &quot;es-3&quot;
		&#125;
	&#125;]
&#125;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p>手动分配分片</p>
<pre class="line-numbers language-none"><code class="language-none">curl -XPOST &quot;http:&#x2F;&#x2F;168.7.1.67:9200&#x2F;_cluster&#x2F;reroute&#39; -d  &#39;&#123;
   &quot;commands&quot; : [&#123;
		&quot;allocate&quot; : &#123;
			&quot;index&quot; : &quot;my-index&quot;,
			&quot;shard&quot; : 0,
			&quot;node&quot; : &quot;es-2&quot;,
		&#125;
	&#125;]
&#125;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="Segments"><a href="#Segments" class="headerlink" title="Segments"></a>Segments</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>GET &#x2F;_cat&#x2F;segments?v</td>
<td>查看集群中各索引的segment信息。包括segment名称、所属shard、内存或磁盘占用大小、是否刷盘等。您也可以指定index，查看该index的segment信息（GET _cat&#x2F;segment&#x2F;<index>?v）。</index></td>
</tr>
</tbody></table>
<h2 id="Mapping"><a href="#Mapping" class="headerlink" title="Mapping"></a>Mapping</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>GET &#x2F;_cat&#x2F;indices?v</td>
<td>查看集群中所有索引的详细信息。包括索引的健康度、状态、分片数和副本数、包含的文档数等。您也可以查看指定索引的信息（GET _cat&#x2F;indices&#x2F;<index>?v）。</index></td>
</tr>
<tr>
<td>GET &#x2F;_cat&#x2F;aliases?v</td>
<td>查看集群中所有aliases（索引别名）的信息。包括aliases对应的索引、路由配置等。</td>
</tr>
</tbody></table>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>GET &#x2F;_cat&#x2F;count?v</td>
<td>查看集群中的文档数量。您也可以指定index，查看该index的文档数量（GET _cat&#x2F;count&#x2F;<index>?v）。</index></td>
</tr>
<tr>
<td>GET &#x2F;<index>&#x2F;<type>&#x2F;<id></id></type></index></td>
<td>查看文档中的数据。</td>
</tr>
</tbody></table>
<h2 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>GET _snapshot&#x2F;_all</td>
<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;查看所有快照。</td>
</tr>
<tr>
<td>GET _snapshot&#x2F;<snapshot_name>&#x2F;_status</snapshot_name></td>
<td>查看指定快照的进度。</td>
</tr>
</tbody></table>
<table>
        <tr>
            <th>设备</th>
            <th>设备文件名</th>
            <th>文件描述符</th>
            <th>类型</th>
        </tr>
        <tr>
            <th>键盘</th>
            <th>/dev/stdin</th>
            <th>0</th>
            <th>标准输入</th>
        </tr>
        <tr>
            <th>显示器</th>
            <th>/dev/stdout</th>
            <th>1</th>
            <th>标准输出</th>
        </tr>
</table>



<h2 id="reindex"><a href="#reindex" class="headerlink" title="reindex"></a>reindex</h2><p>reindex你可以简单理解为scroll+bulkinsert，ES不会帮你复制source的mapping、settings，只会按默认设置自动做映射,建议是先建好新的索引再做reindex</p>
<p>1、新index不创建mapping，则老数据进入新index时会由es自动生成对应mapping，不建议这样</p>
<p>2、新index和老index的mapping对应，则可以正常导过去数据</p>
<pre class="line-numbers language-none"><code class="language-none">POST
&#123;
  &quot;source&quot;: &#123;
    &quot;index&quot;: &quot;old_index&quot;,
	&quot;size&quot;:1000   &#x2F;&#x2F;可选，每次批量提交1000个，可以提高效率，建议每次提交5-15M的数据
	&quot;query&quot;: &#123;
      &quot;match&quot;: &#123;
        &quot;CreateBy&quot;: &quot;xxx&quot;
      &#125;
    &#125;
  &#125;,
  &quot;dest&quot;: &#123;
    &quot;index&quot;: &quot;new_index&quot;
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


<h2 id="settings和mappings的意义"><a href="#settings和mappings的意义" class="headerlink" title="settings和mappings的意义"></a>settings和mappings的意义</h2><p>　　settings是修改分片和副本数的。</p>
<p>　　mappings是修改字段和类型的。类似于mysql中的表结构信息</p>
]]></content>
      <categories>
        <category>elk</category>
        <category>es</category>
      </categories>
      <tags>
        <tag>es</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>es备份</title>
    <url>/posts/3e39/</url>
    <content><![CDATA[<h1 id="快照备份"><a href="#快照备份" class="headerlink" title="快照备份"></a>快照备份</h1><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><pre class="line-numbers language-none"><code class="language-none">PUT _snapshot&#x2F;my_backup 
&#123;
    &quot;type&quot;: &quot;fs&quot;, 
    &quot;settings&quot;: &#123;
        &quot;location&quot;: &quot;&#x2F;mount&#x2F;backups&#x2F;my_backup&quot; 
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li>1、给我们的仓库取一个名字my_backup。</li>
<li>2、我们指定仓库的类型应该是一个共享文件系统。比如nfs共享，挂载在&#x2F;mount&#x2F;backups&#x2F;my_backup</li>
<li>3、最后，我们提供一个已挂载的设备作为目的地址。</li>
<li>4、其他的配置<pre class="line-numbers language-none"><code class="language-none">max_snapshot_bytes_per_sec<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
当快照数据进入仓库时，这个参数控制这个过程的限流情况。默认是每秒 20mb 。<pre class="line-numbers language-none"><code class="language-none">max_restore_bytes_per_sec<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
当从仓库恢复数据时，这个参数控制什么时候恢复过程会被限流以保障你的网络不会被占满。默认是每秒 20mb。<pre class="line-numbers language-none"><code class="language-none">POST _snapshot&#x2F;my_backup&#x2F; 
&#123;
    &quot;type&quot;: &quot;fs&quot;,
    &quot;settings&quot;: &#123;
        &quot;location&quot;: &quot;&#x2F;mount&#x2F;backups&#x2F;my_backup&quot;,
        &quot;max_snapshot_bytes_per_sec&quot; : &quot;50mb&quot;, 
        &quot;max_restore_bytes_per_sec&quot; : &quot;50mb&quot;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
注意我们用的是 POST 而不是 PUT 。这会更新已有仓库的设置。<br>然后添加我们的新设置。</li>
</ul>
<h2 id="快照所有打开的索引"><a href="#快照所有打开的索引" class="headerlink" title="快照所有打开的索引"></a>快照所有打开的索引</h2><pre class="line-numbers language-none"><code class="language-none">PUT _snapshot&#x2F;my_backup&#x2F;snapshot_1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>份所有打开的索引到 my_backup 仓库下 snapshot_1 的快照里</p>
<h2 id="快照指定索引"><a href="#快照指定索引" class="headerlink" title="快照指定索引"></a>快照指定索引</h2><p>这个快照命令现在只会备份 index1 和 index2 了。</p>
<pre class="line-numbers language-none"><code class="language-none">PUT _snapshot&#x2F;my_backup&#x2F;snapshot_2
&#123;
    &quot;indices&quot;: &quot;index_1,index_2&quot;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="列出快照相关的信息"><a href="#列出快照相关的信息" class="headerlink" title="列出快照相关的信息"></a>列出快照相关的信息</h2><p>列出快照snapshot_2的信息</p>
<pre class="line-numbers language-none"><code class="language-none">GET _snapshot&#x2F;my_backup&#x2F;snapshot_2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>获取my_backup仓库下所有的快照信息</p>
<pre class="line-numbers language-none"><code class="language-none">GET _snapshot&#x2F;my_backup&#x2F;_all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="删除快照"><a href="#删除快照" class="headerlink" title="删除快照"></a>删除快照</h2><p>删除snapshot_2快照</p>
<pre class="line-numbers language-none"><code class="language-none">DELETE _snapshot&#x2F;my_backup&#x2F;snapshot_2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h2 id="监控快照进度"><a href="#监控快照进度" class="headerlink" title="监控快照进度"></a>监控快照进度</h2><pre class="line-numbers language-none"><code class="language-none">GET _snapshot&#x2F;my_backup&#x2F;snapshot_2&#x2F;_status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="取消一个快照"><a href="#取消一个快照" class="headerlink" title="取消一个快照"></a>取消一个快照</h2><pre class="line-numbers language-none"><code class="language-none">DELETE _snapshot&#x2F;my_backup&#x2F;snapshot_2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h1 id="从快照恢复"><a href="#从快照恢复" class="headerlink" title="从快照恢复"></a>从快照恢复</h1><p>将snapshot_1恢复。</p>
<pre class="line-numbers language-none"><code class="language-none">POST _snapshot&#x2F;my_backup&#x2F;snapshot_1&#x2F;_restore<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>默认行为是把这个快照里存有的所有索引都恢复，也可以指定这个快照中的具体索引进行恢复。</p>
<h2 id="恢复snapshot-1快照中的index-1索引，并重命名为restored-index-1-只恢复-index-1-索引，忽略快照中存在的其余索引。-查找所提供的模式能匹配上的正在恢复的索引。-然后把它们重命名成替代的模式。"><a href="#恢复snapshot-1快照中的index-1索引，并重命名为restored-index-1-只恢复-index-1-索引，忽略快照中存在的其余索引。-查找所提供的模式能匹配上的正在恢复的索引。-然后把它们重命名成替代的模式。" class="headerlink" title="恢复snapshot_1快照中的index_1索引，并重命名为restored_index_1- 只恢复 index_1 索引，忽略快照中存在的其余索引。- 查找所提供的模式能匹配上的正在恢复的索引。- 然后把它们重命名成替代的模式。"></a>恢复snapshot_1快照中的index_1索引，并重命名为restored_index_1<br><pre class="line-numbers language-none"><code class="language-none">POST &#x2F;_snapshot&#x2F;my_backup&#x2F;snapshot_1&#x2F;_restore
&#123;
    &quot;indices&quot;: &quot;index_1&quot;, 
    &quot;rename_pattern&quot;: &quot;index_(.+)&quot;, 
    &quot;rename_replacement&quot;: &quot;restored_index_$1&quot; 
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>- 只恢复 index_1 索引，忽略快照中存在的其余索引。<br>- 查找所提供的模式能匹配上的正在恢复的索引。<br>- 然后把它们重命名成替代的模式。</h2><h2 id="监控恢复操作"><a href="#监控恢复操作" class="headerlink" title="监控恢复操作"></a>监控恢复操作</h2><pre class="line-numbers language-none"><code class="language-none">GET restored_index_3&#x2F;_recovery<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>或者查看你集群里所有索引，可能包括跟你的恢复进程无关的其他分片移动：</p>
<pre class="line-numbers language-none"><code class="language-none">GET &#x2F;_recovery&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="取消一个恢复"><a href="#取消一个恢复" class="headerlink" title="取消一个恢复"></a>取消一个恢复</h2><p>要取消一个恢复，你需要删除正在恢复的索引。因为恢复进程其实就是分片恢复，发送一个 删除索引 API 修改集群状态，就可以停止恢复进程。比如：</p>
<pre class="line-numbers language-none"><code class="language-none">DELETE &#x2F;restored_index_3<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>如果 restored_index_3 正在恢复中，这个删除命令会停止恢复，同时删除所有已经恢复到集群里的数据。</p>
]]></content>
      <categories>
        <category>elk</category>
        <category>es</category>
      </categories>
      <tags>
        <tag>es</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>es常用插件和工具</title>
    <url>/posts/9317/</url>
    <content><![CDATA[<h1 id="运维工具"><a href="#运维工具" class="headerlink" title="运维工具"></a>运维工具</h1><p><strong>ElasticHQ：</strong><a href="https://github.com/ElasticHQ/elasticsearch-HQ">https://github.com/ElasticHQ/elasticsearch-HQ</a></p>
<p>celebro</p>
<p>kibana</p>
<h1 id="迁移工具"><a href="#迁移工具" class="headerlink" title="迁移工具"></a>迁移工具</h1><p><strong>elasticsearch-migration</strong></p>
<p>github：<a href="https://github.com/medcl/esm-v1">https://github.com/medcl/esm-v1</a></p>
<p><strong>elasticsearch-dump</strong>：</p>
<p>github ：<a href="https://github.com/taskrabbit/elasticsearch-dump">https://github.com/taskrabbit/elasticsearch-dump</a></p>
<p><strong>bigdesk：</strong><a href="https://github.com/lukas-vlcek/bigdesk">https://github.com/lukas-vlcek/bigdesk</a></p>
<p>Elasticsearch-Exporter</p>
<p>logstash</p>
<h1 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h1><p>logstash :<a href="https://www.elastic.co/guide/en/logstash/7.2/index.html">https://www.elastic.co/guide/en/logstash/7.2/index.html</a></p>
<p>kibana    :<a href="https://www.elastic.co/guide/en/kibana/7.2/index.html">https://www.elastic.co/guide/en/kibana/7.2/index.html</a></p>
<p>elastic    :<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.2/index.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.2/index.html</a></p>
<p>filebeat  :<a href="https://www.elastic.co/guide/en/beats/filebeat/7.2/index.html">https://www.elastic.co/guide/en/beats/filebeat/7.2/index.html</a></p>
]]></content>
      <categories>
        <category>elk</category>
        <category>es</category>
      </categories>
      <tags>
        <tag>es</tag>
        <tag>elk</tag>
      </tags>
  </entry>
</search>
